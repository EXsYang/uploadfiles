



# 1 ping通网络需要有三个重要IP配置正确



## 1.1 VMware内部虚拟机的IP `192.168.254.156`

上面这个是静态IP，在`/etc/sysconfig/network-scripts/ifcfg-ens33` 文件中配置的



## 1.2 V8网卡IP `192.168.254.1`

即在物理机(宿主机)的`网络`-`更改适配器选项`中 VMnet8网卡的IP

![image-20250830043559527](https://tgimgbed.999190.xyz/file/1756499763718_image-20250830043559527.png)

这个 `VMware Network Adapter VMnet8` 的 IP 地址 `192.168.254.1` 就是**宿主机**在这个由 VMware 创建的 `VMnet8` 虚拟网络中的 IP 地址。

您可以这样理解：

1. **VMnet8 是一个虚拟交换机**: 当您使用 VMware 的 NAT 模式时，它会创建一个名为 `VMnet8` 的虚拟网络环境，可以看作是一个虚拟的路由器或交换机。
2. **宿主机是网络中的一个设备**: 您的物理电脑（宿主机）也连接到了这个虚拟交换机上，它需要一个 IP 地址才能和这个网络里的其他设备（也就是您的虚拟机）通信。`192.168.254.1` 就是 VMware 分配给宿主机的地址。
3. **虚拟机也是网络中的设备**: 启动后连接到 VMnet8 网络的虚拟机的 IP 地址通常会是 `192.168.254.x` (例如 `192.168.254.128`, `192.168.254.129` 等)，它们的子网掩码也是 `255.255.255.0`。
4. **网关作用**: 对于虚拟机来说，它们的默认网关通常会被设置为 `192.168.254.2`。这个网关地址由 VMware 的虚拟 NAT 服务提供，负责将虚拟机的网络请求通过您的宿主机物理网卡（WLAN 2）转发到外部网络，从而让虚拟机能够访问互联网。

**总结一下：**

- **`192.168.254.1` (VMnet8)**: 是您**宿主机**在虚拟网络中的地址，用于和虚拟机直接通信。
- **`192.168.1.7` (WLAN 2)**: 是您**宿主机**在物理局域网（连接路由器）中的地址，用于连接互联网。



## 1.3 网关IP `192.168.254.2`

编辑网关IP的位置：`VMware软件-编辑-虚拟网络编辑器-NAT设置-网关`



![image-20250830043825822](https://tgimgbed.999190.xyz/file/1756499919473_image-20250830043825822.png)



VMware设置的网关要和在`/etc/sysconfig/network-scripts/ifcfg-ens33` 文件中配置的网关一致

![image-20250830043936949](https://tgimgbed.999190.xyz/file/1756499987693_image-20250830043936949.png)







# 2 遇到宿主机和虚拟机之间可以ping通，但是浏览器http访问不通



访问：[http://192.168.254.156:9011](http://192.168.254.156:9011/) 等不通。即使关闭所有防火墙也还是访问不到http页面。



解决方案：将VMware  还原为默认网络设置，重新配置即可



![image-20250830054417238](https://tgimgbed.999190.xyz/file/1756503879924_image-20250830054417238.png)





# 3 微信小程序测试号id-密钥

| AppID(小程序ID)wx49f8867699133700                     |      |
| ----------------------------------------------------- | ---- |
| AppSecret(小程序密钥)de5c9aa145549acd32ab05902dee791a |      |





# 4 jdk版本选择太高报错：`Cannot determine path to 'tools.jar' library for 17 (C:/jdk/jdk17)`



![image-20250831063805137](https://tgimgbed.999190.xyz/file/1756593495624_image-20250831063805137.png)





您好，这个报错的根本原因是：**`tools.jar` 这个文件在 JDK 9 以及之后的所有版本（包括您正在使用的 JDK 17）中已经被彻底移除了**，但您程序中的某个依赖库仍然在尝试按照旧的方式去寻找它。



### 问题根源：JDK 的历史变迁



- **JDK 8 及之前**：`tools.jar` 文件存在于 JDK 的 `lib` 目录下，它包含了 Java 编译器（`javac`）等核心开发工具的实现。
- **JDK 9 及之后**：Java 引入了模块化系统（Project Jigsaw）。`tools.jar` 的功能被拆分并整合进了 JDK 的标准模块中（例如 `jdk.compiler` 模块）。因此，`tools.jar` 这个物理文件就不再存在了。

您的主程序在 **JDK 17** 环境下启动，但程序中的某个依赖库（通常是比较老的版本）被编写用来支持老的 JDK，它不知道这个变化，仍然固执地去寻找一个早已“搬走”的 `tools.jar` 文件，最终导致启动失败。

这就像一个程序拿着一张十年前的旧地图，想去寻找一个早已搬迁的地址，自然会找不到。



### 问题可能出在哪里？（常见的“罪魁祸首”）



既然是主程序**启动时**报错，问题通常不是出在您的业务代码，而是出在一些需要在运行时动态编译或访问 JVM 工具的**第三方依赖库**上。常见的有：

1. **监控工具 (Jolokia)**：一些老版本的 `jolokia-core` 库（常用于 Spring Boot Actuator）会尝试附加到 JVM，并可能依赖 `tools.jar`。
2. **JSP 编译引擎 (Jasper)**：如果您正在运行一个 Web 应用（尤其是内嵌的 Tomcat），它在运行时编译 JSP 页面时，旧版本可能需要 `tools.jar`。
3. **XML 绑定工具 (JAXB)**：一些独立的、老旧的 JAXB 实现库可能会有此问题。
4. **一些老的字节码操作或切面库**。



### 如何解决？



核心思路是**找到并更新那个过时的依赖库**，让它兼容 Java 17。



#### 方案一（推荐）：更新项目依赖版本



这是最治本、最正确的做法。

1. **检查 Spring Boot 版本**：如果您使用的是 Spring Boot 项目，请确保您使用的 Spring Boot 父版本是与 Java 17 兼容的。**Spring Boot 3.x 系列是为 Java 17 及以上版本设计的**。请检查您 `pom.xml` 中的 `<parent>` 标签：

   XML

   ```
   <parent>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-parent</artifactId>
       <version>3.2.1</version> 
       <relativePath/> 
   </parent>
   ```

   升级 Spring Boot 的父版本会自动管理所有相关依赖（如 Tomcat, Actuator 等）到兼容的版本，通常能直接解决问题。

2. **手动更新问题依赖**：如果不用 Spring Boot 或者想手动解决，您需要找到那个出问题的库。在 `pom.xml` 文件中查找类似 `jolokia-core`, `tomcat-embed-jasper`, `jaxb-impl` 等依赖，并尝试将它们升级到最新的稳定版本。



#### 方案二：分析依赖树来定位问题



如果您不确定是哪个依赖引起的，可以使用 Maven 命令来分析项目的依赖树：

Bash

```
# 在项目根目录下打开命令行执行
mvn dependency:tree
```

在输出的结果中，仔细查找可能存在的老旧版本库（特别是上面提到的那几个“罪魁祸首”），然后针对性地在 `pom.xml` 中进行升级或排除。



#### 方案三（临时方案）：手动添加编译器模块



这是一种“创可贴”式的临时方案，它不能解决根本问题（依赖库老旧），但能让程序先运行起来。

您可以在启动主程序时，添加一个 JVM 参数，手动告诉程序去加载编译器模块：

Bash

```
java --add-modules jdk.compiler -jar your-application.jar
```

如果您是在 IDE (如 IntelliJ IDEA) 中启动，可以把 `--add-modules jdk.compiler` 添加到运行配置 (Run/Debug Configurations) 的 "VM options" 里。

**总结：**

强烈建议您优先使用**方案一**，通过升级项目框架（如 Spring Boot）或相关依赖的版本来解决。这是最稳定、最彻底的办法。





# 5 项目启动的jdk环境是jdk17



![image-20250831074411395](https://tgimgbed.999190.xyz/file/1756597455810_image-20250831074411395.png)





![image-20250831074431872](https://tgimgbed.999190.xyz/file/1756597476034_image-20250831074431872.png)





![image-20250831074431872](https://tgimgbed.999190.xyz/file/1756597489118_1756597476034_image-20250831074431872.png)



运行 右边的maven选项卡-clean和install，此时不再提示jdk版本错误



# 6 mvn指令 使用 -e 参数显示更详细的错误 



~~~
mvn clean compile -e
~~~



好的，没问题。这是一份根据我们刚才的排错过程整理的 Maven 调试笔记，希望能帮助你未来更快地解决类似问题。

------



### **Maven 编译错误调试笔记：从 `Fatal error compiling` 到精确定位问题**





#### **1. 场景回顾**



在对一个多模块的 Maven 项目进行编译时，执行 `mvn clean install` 命令，构建在 `common-util` 模块处失败。



#### **2. 初始错误：模糊的线索**



在未使用任何调试参数时，Maven 输出的错误信息非常笼统，只告诉我们“编译失败”这个结果，但没有提供任何关于“为什么失败”的有效线索。

**未使用 `-e` 时的报错信息：**

```
[INFO] --- maven-compiler-plugin:3.10.1:compile (default-compile) @ common-util ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 14 source files to D:\...\target\classes
[INFO] -------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] -------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.10.1:compile (default-compile) on project common-util: Fatal error compiling
```

**问题分析：**

- `Fatal error compiling` 是一个非常高层的错误。
- 它可能是由多种原因造成的：Java 代码语法错误、依赖找不到 (Cannot find symbol)、环境配置问题等等。
- 仅凭这个信息，我们无法直接定位问题，只能进行猜测，排错效率极低。这就像医生只知道病人说“不舒服”，但不知道具体哪里不舒服。



#### **3. 调试的转折点：`-e` 参数**



为了获取更多线索，我们必须让 Maven “开口说话”。这时，最有用的工具就是 `-e` (或 `--errors`) 参数。

**关键命令：**

Bash

```
# -e 参数会开启错误堆栈跟踪，让我们看到底层的异常信息
mvn clean compile -e
```

作用：

这个参数会强制 Maven 在遇到错误时，打印出完整的异常堆栈 (stack trace)。异常堆栈是 Java 中排查错误的“藏宝图”，它详细记录了错误发生时的函数调用路径和最根本的异常原因。



#### **4. 详细错误：锁定根本原因**



使用了 `-e` 参数后，我们得到了一个信息量暴增的错误日志。在长长的堆栈信息中，我们找到了最关键的那一句：

**使用 `-e` 后的关键报错信息：**

```
[ERROR] Failed to execute goal ... on project common-util: Fatal error compiling: 无效的目标发行版: 17 -> [Help 1]
...
Caused by: org.codehaus.plexus.compiler.CompilerException: 无效的目标发行版: 17
...
Caused by: java.lang.IllegalArgumentException: 无效的目标发行版: 17
```

**问题分析：**

- **“无效的目标发行版: 17”** (Invalid target release: 17) 这条信息非常具体。
- 它不再是模糊的“编译失败”，而是精确地告诉我们：**Java 编译器不接受 "17" 这个目标版本。**
- 这立刻将我们的排查方向从“代码语法问题”或“依赖缺失问题”缩小到了**“JDK 环境与项目配置不匹配”**这一个点上。



#### **5. 问题分析与解决**



有了明确的线索，解决问题就变得水到渠成。

1. **核对项目配置 (`pom.xml`)**：检查 `pom.xml`，发现项目确实配置了需要 Java 17 进行编译。

   XML

   ```
   <properties>
       <java.version>17</java.version>
   </properties>
   ```

2. **核对构建环境**：根据错误信息推断，执行 `mvn` 命令的 Java 环境版本低于 17。通过 `mvn -v` 命令验证，证实了 Maven 正在使用一个旧版本的 JDK（如 JDK 8 或 11）。

3. **制定解决方案**：让环境匹配配置。

   - 安装 JDK 17。
   - 配置系统的 `JAVA_HOME` 和 `Path` 环境变量，使其指向 JDK 17 的安装目录。
   - 同步更新 IDE（如 IntelliJ IDEA）中的项目和 Maven 的 JDK 配置。
   - 重启终端和 IDE 后，问题解决。



#### **6. 总结与反思**



- **核心经验**：遇到模糊的 Maven `BUILD FAILURE` 或 `Fatal error` 时，**第一反应应该是加上 `-e` 参数重新执行**。这是最快、最有效的调试手段。如果 `-e` 还不够，可以使用 `-X` 获取更详细的 debug 级别日志。
- **思维转变**：从“猜测错误原因”转变为“让工具告诉我们错误原因”。
- **环境一致性**：始终确保你的构建环境（终端、IDE）与项目配置文件 (`pom.xml`) 中声明的要求（如 JDK 版本、依赖版本）保持一致。`mvn -v` 是检查 Maven 环境的必备命令。

这份笔记记录了一次典型的 Maven 排错过程，展示了如何利用简单的调试参数，将一个模糊的问题逐步清晰化，并最终高效地解决它。





# 7 Maven 调试笔记：彻底解决JDK 版本冲突导致的`无效的目标发行版`错误





好的，非常感谢你的指正和分享！你提供的参考文章命中了问题的关键，指出了一个我之前笔记中忽略的、至关重要的层面：**开发工具（IDE）本身的版本兼容性**。

你说得对，我之前的解决方案是不完整的。仅仅修改 Windows 的环境变量只能解决**命令行环境**下的 Maven 构建问题，但无法解决**IDE 环境内部**的构建问题。现在，结合你的新发现，我们来重写一份更准确、更全面的调试笔记。

------



### **Maven & IntelliJ 调试笔记：根治 JDK 兼容性噩梦 (`无效目标发行版` 与 `tools.jar`)**





#### **1. 序言：问题的双重性**



在将项目升级到现代 JDK 版本（如 Java 17）时，我们经常会遇到一系列编译错误。这些问题通常成对出现，表面上看起来不同，但根源都指向**环境与配置的不匹配**。这里的“环境”不仅指操作系统的命令行，更包括我们日常使用的 IDE。

本文档记录了解决两大经典错误的完整过程：

1. `无效的目标发行版: 17` (Invalid target release: 17)
2. `Cannot determine path to 'tools.jar' library for 17`



#### **2. 第一幕：命令行的挑战 - `无效的目标发行版`**



当我们首次在终端（命令行）中运行 `mvn clean install` 时，往往会遇到第一个错误。

- **症状:** 终端报错 `无效的目标发行版: 17`。
- **诊断:** 通过 `mvn -v` 命令，我们发现 Maven 是由一个旧版本的 JDK（如 JDK 8）来运行的，而项目的 `pom.xml` 要求使用 JDK 17 编译。旧的 JDK 编译器不认识新版本的指令，因此报错。
- **解决方案:**
  1. 安装 JDK 17。
  2. 修正操作系统的环境变量，将 `JAVA_HOME` 指向 JDK 17 的安装目录，并将其 `%JAVA_HOME%\bin` 添加到 `Path` 的最前端。
  3. 重启终端，再次用 `mvn -v` 确认 Maven 已经运行在 JDK 17 环境下。

**至此，命令行的构建问题解决了。但当我们回到 IDE 时，噩梦进入了第二幕。**



#### **3. 第二幕：IDE 的陷阱 - `Cannot determine path to 'tools.jar'`**



在 IntelliJ IDEA 中尝试构建或运行项目时，出现了第二个，也是更令人困惑的错误。

- **症状:** IntelliJ IDEA 内部报错 `Cannot determine path to 'tools.jar' library for 17`。
- **错误分析:**
  - **历史背景:** `tools.jar` 是 JDK 8 及其之前版本的一个核心库，包含了编译器等工具。**从 JDK 9 开始，随着 Java 模块化系统的引入，`tools.jar` 文件被彻底移除。**
  - **根本原因:** 错误信息提示要寻找一个在 JDK 17 中根本不存在的文件，这说明**调用者本身“过时”了**。它不理解 JDK 17 的模块化结构，因此回退到一种旧的、基于 `tools.jar` 的方式去尝试解析 JDK，最终必然失败。
  - **真正的“元凶”:** 正如你分享的文章所指出的，这个“过时的调用者”就是 **IntelliJ IDEA 本身**。一个旧版本的 IDE（如 2020.1.2）其核心功能最高只支持解析到某个特定版本的 JDK（如 JDK 14）。当它被强制要求使用它无法理解的 JDK 17 时，其内部的构建和分析引擎就会出错。



#### **4. 终极解决方案：四大环境全面对齐**



要彻底解决这个问题，必须确保从操作系统到 IDE 再到项目配置，所有环节都协调一致。

1. **系统环境对齐 (解决命令行问题)**

   - **操作:** 设置 `JAVA_HOME` 和 `Path` 环境变量，使其指向你的目标 JDK 版本（JDK 17）。
   - **验证:** 在**新**终端中执行 `mvn -v`，确认 Java version 为 17。

2. **IDE 版本对齐 (解决 `tools.jar` 问题的核心)**

   - **操作:** **升级你的 IntelliJ IDEA 到一个明确支持 Java 17 的现代版本。** 例如，根据 JetBrains 的官方文档，至少需要 **`2021.2.1`** 或更新的版本。
   - **解释:** 这是最关键的一步。只有 IDE 本身足够新，它才能正确地解析和集成新的 JDK。

3. **IDE 内部配置对齐**

   - **操作:** 在升级后的新版 IDEA 中，检查并设置以下两处：
     - `File` -> `Project Structure` -> `Project SDK`：设置为 JDK 17。
     - `Settings/Preferences` -> `Build, Execution, Deployment` -> `Build Tools` -> `Maven` -> `JDK for importer`：设置为 JDK 17。

4. **项目配置对齐**

   - **操作:** 确保项目的 `pom.xml` 中明确指定了 Java 版本。

     XML

     ```
     <properties>
         <java.version>17</java.version>
     </properties>
     ```



#### **5. 总结与反思**



- **最核心的教训：** 开发工具链（IDE、构建工具）必须与开发语言（JDK）的版本相匹配。**一个过时的 IDE 无法正确构建一个使用新版 JDK 的项目**，无论你的系统环境变量和项目配置多么正确。
- **`tools.jar` 错误是“时代眼泪”：** 当你为新版 JDK 看到这个错误时，几乎可以 100% 确定是某个工具（插件、IDE）的版本太旧了。
- **整体性思维：** 现代 Java 开发的环境配置是一个整体。`JAVA_HOME`、`IDE 版本`、`IDE 配置` 和 `pom.xml` 必须形成一个完整的、无冲突的链条。任何一环的短板都可能导致看似奇怪的构建失败。



# 8 报错：`Cannot determine path to 'tools.jar' library for 17 (C:/jdk/jdk17)`

解决IntelliJ IDEA报错Error:Cannot determine path to 'tools.jar' library for 17 (C:\Program Files\Java\jdk-17
方法 1
方法 2
  这个月，Java 17 终于发布了。这是继 Java 11 之后的又一个 LTS 版本。没事找事的笔者决定试试 Java 17。果然，意料之中的事情发生了：笔者使用 Java 17 运行一个曾经运行正常的项目时，IntelliJ IDEA 发生了如下报错：

笔者报错时的运行环境：

IntelliJ IDEA 2020.1.2 (Ultimate Edition)

JDK 17

Error:Cannot determine path to 'tools.jar' library for 17 (C:\Program Files\Java\jdk-17)
AI写代码
cmd
1
  然后，和以前一样。笔者又试着运行一个非常简单的 demo 项目，果然又发生了相同的报错。而该项目以前运行正常时的环境为：

该项目以前运行正常时的环境：

IntelliJ IDEA 2020.1.2 (Ultimate Edition)

JDK 11

  笔者曾经屡次在不同的操作系统上安装过多个版本的 Java，对这个报错非常熟悉。这个报错说明，当前的 IntelliJ IDEA 无法解析这个版本的 JDK，所以它尝试从它内置的环境变量 CLASSPATH 来解析 tools.jar，结果还是失败，因此它抛出了如上的报错信息。

  可以印证这一点。在下图的 Project Structure 中可以清晰的看到，笔者的 IntelliJ IDEA 2020.1.2 (Ultimate Edition) 最高支持解析 JDK 14，因此对 Java 17 无能为力。

![在这里插入图片描述](https://tgimgbed.999190.xyz/file/1756600855301_1756600463116_88b4e98a5589e44c3672f3c63fbec8ef.png)

![在这里插入图片描述](https://tgimgbed.999190.xyz/file/1756600858598_1756600484600_4a9cdd99b654ea832c572ac4146b8c89.png)



方法 1
  知道原因了就好办了。一种方法是降低 JDK 的版本，使当前 IntelliJ IDEA 能够识别。

该项目以前运行正常时的环境：

IntelliJ IDEA 2020.1.2 (Ultimate Edition)

JDK 11

  先安装低版本的 JDK，然后再在 IntelliJ IDEA 中的 Project Structure 中设置。如下图。不过笔者通常不喜欢这样做。

![](https://tgimgbed.999190.xyz/file/1756600858955_1756600487379_1756600484600_4a9cdd99b654ea832c572ac4146b8c89.png)

方法 2
  另一种办法是提高 IntelliJ IDEA 的版本。为此，笔者专门下载并安装了当时最新版本的 IntelliJ IDEA：IntelliJ IDEA 2021.2.2 (Ultimate Edition) 。出人意料而又在情理之中的是，笔者安装最新的 IntelliJ IDEA 时又遇到很多坑。笔者一直很想站在巨人的肩膀上，但实际上总是被巨人当做垫脚石。关于安装 IntelliJ IDEA 后打不开的问题，可见笔者的另一篇博客：

解决 IntelliJ IDEA 安装后界面消失，再次打开后界面不动：
https://blog.csdn.net/wangpaiblog/article/details/120425678

  IntelliJ IDEA 的官网是：https://www.jetbrains.com/idea/。刚下载的时候，笔者还担心它也不能解析 Java 17，不过现在看来这种担心是多余的。

该项目运行正常时的环境：

IntelliJ IDEA 2021.2.2 (Ultimate Edition)

JDK 17

  升级完 IntelliJ IDEA 之后，将 Project Structure 进行如下配置即可。

![在这里插入图片描述](https://tgimgbed.999190.xyz/file/1756600856741_1756600547382_32754978012114637cf0d816abb48ede.png)