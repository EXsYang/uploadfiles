# 1.let细节 注意

直接输出x,会报错！

![image-20230819192451389](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819192451389.png)

![image-20230819192500011](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819192500011.png)

---

在输出语句后面使用var定义变量x，会变量提升，输出undefined

![image-20230819192721942](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819192721942.png)

![image-20230819192822282](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819192822282.png)

---



![image-20230819193152185](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819193152185.png)

![image-20230819193208755](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819193208755.png)



---

![image-20230819193451906](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819193451906.png)

![image-20230819193349938](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230819193349938.png)









---

# 2 Vue 笔记

## 1 控制台直接使用vm对象

![image-20230825204602162](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230825204602162.png)

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue快速入门</title>
</head>
<body>
<!--老师解读
1. div元素不是必须的，也可以是其它元素，比如span,但是约定都是将vue实例挂载到div
2. 因为div更加适合做布局
3. id 不是必须为app , 是程序员指定,一般我们就使用app
-->
<div id="app">
    <!--老师解读
    1. {{message}} : 插值表达式
    2. message 就是从model的data数据池来设置
    3. 当我们的代码执行时，会到data{} 数据池中去匹配数据, 如果匹配上, 就进行替换
       , 如果没有匹配上, 就是输出空
    -->
    <h1>欢迎你{{message}}-{{name}}</h1>
</div>
<!--引入vue.js-->
<script src="vue.js"></script>
<script>
    //创建Vue对象
    /**
     * 老韩解读
     * 1. 创建Vue对象实例
     * 2. 我们在控制台输出vm对象，看看该对象的结构！(data/listeners)
     *
     */
    let vm = new Vue({
        el: "#app", //创建的vue实例挂载到 id=app的div
        data: { //data{} 表示数据池(model的有了数据), 有很多数据 ,以k-v形式设置(根据业务需要来设置)
            message: "Hello-Vue!",
            name: "韩顺平教育"
        }
    })
    console.log("vm=>", vm);
    console.log(vm._data.message);
    console.log(vm._data.name);
    console.log(vm.name);
    console.log(vm.message);
</script>

</body>
</html>
~~~



---

## 2 idea 中 v-bind 爆红问题

![image-20230825214927058](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230825214927058.png)



alt + enter 引入一下即可  引入xml的命名空间

![image-20230825215014325](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230825215014325.png)





![image-20230825214805598](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230825214805598.png)



---

## 3 url书写格式注意

https://www.baidu.com/ 冒号写在http后面再后面是//

![image-20230826170027286](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230826170027286.png)

---



## 4 v-if   v-on: 后面可以直接写一个条件表达式

```

<h1>欢迎你{{message}}-{{name}}</h1>

单向数据渲染
<img v-bind:src="img_src" v-bind:width="img_width">
<img :src="img_src" :width="img_width">

双向数据渲染
<input type="text" v-model="hobby.val"><br/><br/>

Vue修饰符使用
<form action="http://www.baidu.com" v-on:submit.prevent="onMySubmit">
        妖怪名: <input type="text" v-model="monster.name"><br/><br/>  
<button v-on:click.once="onMySubmit">点击一次</button><br/>
<input type="text" v-on:keyup.enter="onMySubmit">
<input type="text" v-on:keyup.down="onMySubmit">
<input type="text" v-model.trim="count">

事件处理
<button v-on:click="sayHi()">点击输出</button>
<button v-on:click="count += 2">点击增加+2</button>
<button @click="sayHi()">点击输出</button>


<button v-on:click="count += 2">点击增加+2</button>

条件渲染 v-if
<div v-if="score >= 90">你的成绩优秀</div>
<div v-else-if="score >= 70">你的成绩良好</div>
<div v-else-if="score >= 60">你的成绩及格</div>
<div v-else="score < 60">你的成绩不及格</div>
v-for 列表渲染
<ul>
  <li v-for="item in items" :key="item.id">...</li>
</ul>
```

~~~
<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>事件处理-作业1</title>
</head>
<body>
<div id="app">
    <h1>{{message}}</h1>
    <button v-on:click="add">点击增加+1</button>
    <!--老师解读
    1. 这里count += 2 的count数据是data数据池的count
    2. 案例不难，重点是掌握和理解机制
    -->


    <button v-on:click="add2">点击增加+2</button>
    <!--add2()函数只有一句话 this.count += 2;
    Vue 支持直接写在 v-on:click="" 里 因为在这写 脱离了下面的vm Vue对象实例 所以 把this拿掉
    this 只可以在对象里面使用；问题是在这里写count += 2 它能不能找到数据池里的 count
    可以 因为上来就把vm Vue对象挂载到了 id="app"的div 所以在此处去找count时 它发现count并不是一个方法
    它就会自动的去数据池里面找，找到count ,因此 这里的count 还是数据池里的数据count
    -->
    <button v-on:click="this.count += 2">点击增加+2</button>
    <button v-on:click="count += 2">点击增加+2</button>

    <p>你的按钮被点击了{{count}}次</p>
</div>
<script src="vue.js"></script>
<!--创建一个vue实例,并挂载到id=app的div-->
<script>
    let vm = new Vue({
        el: "#app", //创建的vue实例挂载到 id=app的div, el 就是element的简写
        data: { //data{} 表示数据池(model中的数据), 有很多数据 ,以k-v形式设置(根据业务需要来设置)
            message: "Vue事件处理的作业",
            count: 0//点击的次数
        },
        methods: {
            add() {
                //修改data数据池的count
                //因为data和methods在同一个vue实例中,因此可以通过this.数据方式访问
                this.count += 1;
            },
            add2() {
                //修改data数据池的count
                //因为data和methods在同一个vue实例中,因此可以通过this.数据方式访问
                this.count += 2;
            }
        }
    })
</script>
</body>
</html>
~~~



---

## 5 如何查看是否安装了node.js

cmd控制台 输入 node -v 回车

安装过会显示版本号：

![image-20230828110254161](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828110254161.png)

没安装过 ：

![image-20230828110231859](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828110231859.png)



---

## 6 安装node时出现错误

~~~
C:\WINDOWS\system32>cnpm install -g @vue/cli@4.0.3
internal/modules/cjs/loader.js:638
    throw err;
    ^

Error: Cannot find module 'node:util'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)
    at Function.Module._load (internal/modules/cjs/loader.js:562:25)
    at Module.require (internal/modules/cjs/loader.js:692:17)
    at require (internal/modules/cjs/helpers.js:25:18)
    at Object.<anonymous> (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm:3:15)
    at Module._compile (internal/modules/cjs/loader.js:778:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)
    at Module.load (internal/modules/cjs/loader.js:653:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)
    at Function.Module._load (internal/modules/cjs/loader.js:585:3)
~~~



![image-20230828143733432](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828143733432.png)

解决方法：

https://blog.csdn.net/qq_41619841/article/details/129869658



npm和cnpm的版本不匹配，需要匹配版本(记得先删除之前的)：

~~~
npm uninstall cnpm
~~~



当前npm版本：在命令行输入指令时记得输入的是# 后面的npm -v

~~~
C:\WINDOWS\system32>node -v
v10.16.3

C:\WINDOWS\system32>npm -v
6.9.0

~~~


**全局安装cnpm指定版本：这里这句话解决了问题!!!**

~~~
npm install -g cnpm@6.0.0 --registry=https://registry.npm.taobao.org
~~~


~~~
C:\WINDOWS\system32>npm install -g cnpm@6.0.0 --registry=https://registry.npm.taobao.org

npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.
npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142
npm WARN deprecated har-validator@5.1.5: this library is no longer supported
C:\Users\yangd\AppData\Roaming\npm\cnpm -> C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm
npm WARN urllib@2.41.0 requires a peer of proxy-agent@^5.0.0 but none is installed. You must install peer dependencies yourself.

+ cnpm@6.0.0
added 388 packages from 138 contributors, removed 401 packages and updated 188 packages in 59.646s
~~~

![image-20230828145234665](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828145234665.png)


查看cnpm的版本:

~~~
 cnpm -v
~~~


如下即为成功:

C:\WINDOWS\system32>cnpm -v
cnpm@6.0.0 (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\lib\parse_argv.js)
npm@6.14.18 (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\node_modules\npm\lib\npm.js)
node@10.16.3 (D:\Java_developer_tools\program\nodejs10.16\node.exe)
npminstall@3.28.1 (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\node_modules\npminstall\lib\index.js)
prefix=C:\Users\yangd\AppData\Roaming\npm
win32 x64 10.0.19045
registry=https://registry.npm.taobao.org



**安装vue cli 脚手架时 命令行具体执行代码如下：**

~~~
Microsoft Windows [版本 10.0.19045.3324]
(c) Microsoft Corporation。保留所有权利。

C:\WINDOWS\system32>node -v
v10.16.3

C:\WINDOWS\system32>npm uninstall vue-cli -g
up to date in 0.029s

C:\WINDOWS\system32>npm install -g cnpm --registry=https://registry.npm.taobao.org
C:\Users\yangd\AppData\Roaming\npm\cnpm -> C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm
npm WARN urllib@2.41.0 requires a peer of proxy-agent@^5.0.0 but none is installed. You must install peer dependencies yourself.

+ cnpm@9.2.0
updated 249 packages in 39.775s

C:\WINDOWS\system32>npm install webpack@4.41.2 webpack-cli -D
npm WARN saveError ENOENT: no such file or directory, open 'C:\WINDOWS\system32\package.json'
npm WARN enoent ENOENT: no such file or directory, open 'C:\WINDOWS\system32\package.json'
npm WARN @webpack-cli/configtest@2.1.1 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/info@2.0.2 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/serve@2.0.5 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN webpack-cli@5.1.4 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN system32 No description
npm WARN system32 No repository field.
npm WARN system32 No README data
npm WARN system32 No license field.
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.13 (node_modules\watchpack-chokidar2\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.13: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})

+ webpack-cli@5.1.4
+ webpack@4.41.2
updated 2 packages and audited 600 packages in 7.088s
found 3 high severity vulnerabilities
  run `npm audit fix` to fix them, or `npm audit` for details

C:\WINDOWS\system32>cnpm install -g @vue/cli@4.0.3
internal/modules/cjs/loader.js:638
    throw err;
    ^

Error: Cannot find module 'node:util'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)
    at Function.Module._load (internal/modules/cjs/loader.js:562:25)
    at Module.require (internal/modules/cjs/loader.js:692:17)
    at require (internal/modules/cjs/helpers.js:25:18)
    at Object.<anonymous> (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm:3:15)
    at Module._compile (internal/modules/cjs/loader.js:778:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)
    at Module.load (internal/modules/cjs/loader.js:653:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)
    at Function.Module._load (internal/modules/cjs/loader.js:585:3)

C:\WINDOWS\system32>cnpm install webpack@4.41.2 webpack-cli -D
internal/modules/cjs/loader.js:638
    throw err;
    ^

Error: Cannot find module 'node:util'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)
    at Function.Module._load (internal/modules/cjs/loader.js:562:25)
    at Module.require (internal/modules/cjs/loader.js:692:17)
    at require (internal/modules/cjs/helpers.js:25:18)
    at Object.<anonymous> (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm:3:15)
    at Module._compile (internal/modules/cjs/loader.js:778:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)
    at Module.load (internal/modules/cjs/loader.js:653:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)
    at Function.Module._load (internal/modules/cjs/loader.js:585:3)

C:\WINDOWS\system32>npm audit fix
npm ERR! code EAUDITNOPJSON
npm ERR! audit No package.json found: Cannot audit a project without a package.json

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\yangd\AppData\Roaming\npm-cache\_logs\2023-08-28T06_20_26_816Z-debug.log

C:\WINDOWS\system32>npm init --yes
Wrote to C:\WINDOWS\system32\package.json:

{
  "name": "system32",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "dependencies": {
    "webpack-cli": "^5.1.4",
    "webpack": "^4.41.2"
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}



C:\WINDOWS\system32>npm audit fix
npm WARN @webpack-cli/configtest@2.1.1 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/info@2.0.2 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/serve@2.0.5 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN webpack-cli@5.1.4 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN system32@1.0.0 No description
npm WARN system32@1.0.0 No repository field.
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.13 (node_modules\watchpack-chokidar2\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.13: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})

up to date in 1.447s
fixed 0 of 1 vulnerability in 387 scanned packages
  1 package update for 1 vuln involved breaking changes
  (use `npm audit fix --force` to install breaking changes; or refer to `npm audit` for steps to fix these manually)

C:\WINDOWS\system32>npm install webpack@^4.41.2 --save-dev
npm WARN deprecated source-map-resolve@0.5.3: See https://github.com/lydell/source-map-resolve#deprecated
npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated
npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated
npm WARN deprecated source-map-url@0.4.1: See https://github.com/lydell/source-map-url#deprecated
npm WARN deprecated chokidar@2.1.8: Chokidar 2 does not receive security updates since 2019. Upgrade to chokidar 3 with 15x fewer dependencies
npm WARN deprecated fsevents@1.2.13: The v1 package contains DANGEROUS / INSECURE binaries. Upgrade to safe fsevents v2
npm notice save webpack is being moved from dependencies to devDependencies
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules\chokidar\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.2.7 (node_modules\watchpack-chokidar2\node_modules\chokidar\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.13: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})
npm WARN @webpack-cli/configtest@2.1.1 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/info@2.0.2 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/serve@2.0.5 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN webpack-cli@5.1.4 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN system32@1.0.0 No description
npm WARN system32@1.0.0 No repository field.

+ webpack@4.41.2
updated 1 package and audited 387 packages in 35.631s
found 1 high severity vulnerability
  run `npm audit fix` to fix them, or `npm audit` for details

C:\WINDOWS\system32>
C:\WINDOWS\system32>npm audit fix
npm WARN @webpack-cli/configtest@2.1.1 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/info@2.0.2 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/serve@2.0.5 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN webpack-cli@5.1.4 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN system32@1.0.0 No description
npm WARN system32@1.0.0 No repository field.
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.13 (node_modules\watchpack-chokidar2\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.13: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})

up to date in 1.455s
fixed 0 of 1 vulnerability in 387 scanned packages
  1 package update for 1 vuln involved breaking changes
  (use `npm audit fix --force` to install breaking changes; or refer to `npm audit` for steps to fix these manually)

C:\WINDOWS\system32>cnpm install -g @vue/cli@4.0.3
internal/modules/cjs/loader.js:638
    throw err;
    ^

Error: Cannot find module 'node:util'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)
    at Function.Module._load (internal/modules/cjs/loader.js:562:25)
    at Module.require (internal/modules/cjs/loader.js:692:17)
    at require (internal/modules/cjs/helpers.js:25:18)
    at Object.<anonymous> (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm:3:15)
    at Module._compile (internal/modules/cjs/loader.js:778:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)
    at Module.load (internal/modules/cjs/loader.js:653:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)
    at Function.Module._load (internal/modules/cjs/loader.js:585:3)

C:\WINDOWS\system32>npm uninstall cnpm
npm WARN @webpack-cli/configtest@2.1.1 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/info@2.0.2 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN @webpack-cli/serve@2.0.5 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN webpack-cli@5.1.4 requires a peer of webpack@5.x.x but none is installed. You must install peer dependencies yourself.
npm WARN system32@1.0.0 No description
npm WARN system32@1.0.0 No repository field.
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.13 (node_modules\watchpack-chokidar2\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.13: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})

audited 387 packages in 3.01s
found 1 high severity vulnerability
  run `npm audit fix` to fix them, or `npm audit` for details

C:\WINDOWS\system32>[root@localhost ~]# npm install -g cnpm@6.0.0 --registry=https://registry.npm.taobao.org
'[root@localhost' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

C:\WINDOWS\system32>npm install -g cnpm@6.0.0 --registry=https://registry.npm.taobao.org
npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.
npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142
npm WARN deprecated har-validator@5.1.5: this library is no longer supported
C:\Users\yangd\AppData\Roaming\npm\cnpm -> C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\bin\cnpm
npm WARN urllib@2.41.0 requires a peer of proxy-agent@^5.0.0 but none is installed. You must install peer dependencies yourself.

+ cnpm@6.0.0
added 388 packages from 138 contributors, removed 401 packages and updated 188 packages in 59.646s

C:\WINDOWS\system32>cnpm install -g @vue/cli@4.0.3
Downloading @vue/cli to C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli_tmp
Copying C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli_tmp\_@vue_cli@4.0.3@@vue\cli to C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli
Installing @vue/cli's dependencies to C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli/node_modules
[1/36] deepmerge@^3.2.0 installed at node_modules\_deepmerge@3.3.0@deepmerge
[2/36] commander@^2.20.0 installed at node_modules\_commander@2.20.3@commander
[3/36] @vue/cli-ui-addon-widgets@^4.0.3 installed at node_modules\_@vue_cli-ui-addon-widgets@4.5.19@@vue\cli-ui-addon-widgets
[4/36] @vue/cli-ui-addon-webpack@^4.0.3 installed at node_modules\_@vue_cli-ui-addon-webpack@4.5.19@@vue\cli-ui-addon-webpack
[5/36] debug@^4.1.0 installed at node_modules\_debug@4.3.4@debug
[6/36] execa@^1.0.0 existed at node_modules\_execa@1.0.0@execa
[7/36] didyoumean@^1.2.1 installed at node_modules\_didyoumean@1.2.2@didyoumean
[8/36] ejs@^2.6.1 installed at node_modules\_ejs@2.7.4@ejs
[9/36] envinfo@^7.2.0 installed at node_modules\_envinfo@7.10.0@envinfo
[10/36] chalk@^2.4.1 installed at node_modules\_chalk@2.4.2@chalk
[11/36] boxen@^4.1.0 installed at node_modules\_boxen@4.2.0@boxen
[12/36] javascript-stringify@^1.6.0 installed at node_modules\_javascript-stringify@1.6.0@javascript-stringify
[13/36] cmd-shim@^2.0.2 installed at node_modules\_cmd-shim@2.1.0@cmd-shim
[14/36] isbinaryfile@^4.0.0 installed at node_modules\_isbinaryfile@4.0.10@isbinaryfile
[15/36] import-global@^0.1.0 installed at node_modules\_import-global@0.1.0@import-global
[16/36] lru-cache@^5.1.1 existed at node_modules\_lru-cache@5.1.1@lru-cache
[17/36] minimist@^1.2.0 existed at node_modules\_minimist@1.2.8@minimist
[18/36] lodash.clonedeep@^4.5.0 installed at node_modules\_lodash.clonedeep@4.5.0@lodash.clonedeep
[19/36] request@^2.87.0 existed at node_modules\_request@2.88.2@request
[20/36] fs-extra@^7.0.1 installed at node_modules\_fs-extra@7.0.1@fs-extra
[21/36] resolve@^1.10.1 existed at node_modules\_resolve@1.22.4@resolve
[22/36] semver@^6.1.0 existed at node_modules\_semver@6.3.1@semver
[23/36] js-yaml@^3.13.1 installed at node_modules\_js-yaml@3.14.1@js-yaml
[24/36] slash@^3.0.0 installed at node_modules\_slash@3.0.0@slash
[25/36] @vue/cli-shared-utils@^4.0.3 installed at node_modules\_@vue_cli-shared-utils@4.5.19@@vue\cli-shared-utils
[26/36] recast@^0.18.1 installed at node_modules\_recast@0.18.10@recast
[27/36] shortid@^2.2.11 installed at node_modules\_shortid@2.2.16@shortid
[28/36] download-git-repo@^1.0.2 installed at node_modules\_download-git-repo@1.1.0@download-git-repo
[29/36] validate-npm-package-name@^3.0.0 installed at node_modules\_validate-npm-package-name@3.0.0@validate-npm-package-name
[30/36] globby@^9.2.0 installed at node_modules\_globby@9.2.0@globby
[31/36] yaml-front-matter@^3.4.1 installed at node_modules\_yaml-front-matter@3.4.1@yaml-front-matter
[32/36] vue-jscodeshift-adapter@^2.0.2 installed at node_modules\_vue-jscodeshift-adapter@2.2.0@vue-jscodeshift-adapter
[33/36] jscodeshift@^0.6.4 installed at node_modules\_jscodeshift@0.6.4@jscodeshift
[34/36] request-promise-native@^1.0.7 installed at node_modules\_request-promise-native@1.0.9@request-promise-native
[35/36] inquirer@^6.3.1 installed at node_modules\_inquirer@6.5.2@inquirer
[36/36] @vue/cli-ui@^4.0.3 installed at node_modules\_@vue_cli-ui@4.5.19@@vue\cli-ui
execute post install 3 scripts...
[1/3] scripts.postinstall ejs@^2.6.1 run "node ./postinstall.js", root: "C:\\Users\\yangd\\AppData\\Roaming\\npm\\node_modules\\@vue\\cli\\node_modules\\_ejs@2.7.4@ejs"
Thank you for installing EJS: built with the Jake JavaScript build tool (https://jakejs.com/)

[1/3] scripts.postinstall ejs@^2.6.1 finished in 257ms
[2/3] scripts.postinstall @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-reporting-protobuf@0.8.0 › @apollo/protobufjs@1.2.2 run "node scripts/postinstall", root: "C:\\Users\\yangd\\AppData\\Roaming\\npm\\node_modules\\@vue\\cli\\node_modules\\_@apollo_protobufjs@1.2.2@@apollo\\protobufjs"
[2/3] scripts.postinstall @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-reporting-protobuf@0.8.0 › @apollo/protobufjs@1.2.2 finished in 171ms
[3/3] scripts.postinstall @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-graphql@0.9.7 › core-js-pure@^3.10.2 run "node -e \"try{require('./postinstall')}catch(e){}\"", root: "C:\\Users\\yangd\\AppData\\Roaming\\npm\\node_modules\\@vue\\cli\\node_modules\\_core-js-pure@3.32.1@core-js-pure"
Thank you for using core-js ( https://github.com/zloirock/core-js ) for polyfilling JavaScript standard library!

The project needs your help! Please consider supporting core-js:
> https://opencollective.com/core-js
> https://patreon.com/zloirock
> https://boosty.to/zloirock
> bitcoin: bc1qlea7544qtsmj2rayg0lthvza9fau63ux0fstcz

I highly recommend reading this: https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md

[3/3] scripts.postinstall @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-graphql@0.9.7 › core-js-pure@^3.10.2 finished in 115ms
peerDependencies WARNING @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-server-env@3.2.0 › node-fetch@^2.6.1 requires a peer of encoding@^0.1.0 but none was installed
peerDependencies WARNING @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › subscriptions-transport-ws@0.9.19 › ws@^5.2.0 || ^6.0.0 || ^7.0.0 requires a peer of bufferutil@^4.0.1 but none was installed
peerDependencies WARNING @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › subscriptions-transport-ws@0.9.19 › ws@^5.2.0 || ^6.0.0 || ^7.0.0 requires a peer of utf-8-validate@^5.0.2 but none was installed
deprecate @vue/cli-shared-utils@4.5.19 › @hapi/joi@^15.0.1 Switch to 'npm install joi'
deprecate @vue/cli-shared-utils@4.5.19 › request@^2.88.2 request has been deprecated, see https://github.com/request/request/issues/3142
deprecate @vue/cli-shared-utils@4.5.19 › @hapi/joi@15.1.1 › @hapi/bourne@1.x.x This version has been deprecated and is no longer supported or maintained
deprecate @vue/cli-shared-utils@4.5.19 › request@2.88.2 › har-validator@~5.1.3 this library is no longer supported
deprecate @vue/cli-shared-utils@4.5.19 › @hapi/joi@15.1.1 › @hapi/topo@3.x.x This version has been deprecated and is no longer supported or maintained
deprecate @vue/cli-shared-utils@4.5.19 › @hapi/joi@15.1.1 › @hapi/address@2.x.x Moved to 'npm install @sideway/address'
deprecate @vue/cli-shared-utils@4.5.19 › @hapi/joi@15.1.1 › @hapi/hoek@8.x.x This version has been deprecated and is no longer supported or maintained
deprecate @vue/cli-shared-utils@4.5.19 › request@2.88.2 › uuid@^3.3.2 Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.
deprecate request-promise-native@^1.0.7 request-promise-native has been deprecated because it extends the now deprecated request package, see https://github.com/request/request/issues/3142
deprecate shortid@^2.2.11 Package no longer supported. Contact Support at https://www.npmjs.com/support for more info.
deprecate globby@9.2.0 › fast-glob@2.2.7 › micromatch@3.1.10 › snapdragon@0.8.2 › source-map-resolve@^0.5.0 See https://github.com/lydell/source-map-resolve#deprecated
deprecate globby@9.2.0 › fast-glob@2.2.7 › micromatch@3.1.10 › snapdragon@0.8.2 › source-map-resolve@0.5.3 › urix@^0.1.0 Please see https://github.com/lydell/urix#deprecated
deprecate globby@9.2.0 › fast-glob@2.2.7 › micromatch@3.1.10 › snapdragon@0.8.2 › source-map-resolve@0.5.3 › source-map-url@^0.4.0 See https://github.com/lydell/source-map-url#deprecated
deprecate globby@9.2.0 › fast-glob@2.2.7 › micromatch@3.1.10 › snapdragon@0.8.2 › source-map-resolve@0.5.3 › resolve-url@^0.2.1 https://github.com/lydell/resolve-url#deprecated
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@^2.13.1 The `apollo-server-express` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023 and October 22nd 2024, respectively). This package's functionality is now found in the `@apollo/server` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
anti semver @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › @types/express@4.17.17 › @types/body-parser@* delcares @types/body-parser@*(resolved as 1.19.2) but using ancestor(apollo-server-express)'s dependency @types/body-parser@1.19.0(resolved as 1.19.0)
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@^0.10.0 The `apollo-server-types` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023). This package's functionality is now found in the `@apollo/server` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-reporting-protobuf@^0.8.0 The `apollo-reporting-protobuf` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023). This package's functionality is now found in the `@apollo/usage-reporting-protobuf` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-server-caching@^0.7.0 This package is part of the legacy caching implementation used by Apollo Server v2 and v3, and is no longer maintained. We recommend you switch to the newer Keyv-based implementation (which is compatible with all versions of Apollo Server). See https://www.apollographql.com/docs/apollo-server/v3/performance/cache-backends#legacy-caching-implementation for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-server-env@^3.2.0 The `apollo-server-env` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023). This package's functionality is now found in the `@apollo/utils.fetcher` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › subscriptions-transport-ws@^0.9.19 The `subscriptions-transport-ws` package is no longer maintained. We recommend you use `graphql-ws` instead. For help migrating Apollo software to `graphql-ws`, see https://www.apollographql.com/docs/apollo-server/data/subscriptions/#switching-from-subscriptions-transport-ws    For general help using `graphql-ws`, see https://github.com/enisdenjo/graphql-ws/blob/master/README.md
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@^2.26.1 The `apollo-server-core` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023 and October 22nd 2024, respectively). This package's functionality is now found in the `@apollo/server` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-datasource@^0.10.0 The `apollo-datasource` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023). See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › graphql-tools@^4.0.8 This package has been deprecated and now it only exports makeExecutableSchema.
And it will no longer receive updates.
We recommend you to migrate to scoped packages such as @graphql-tools/schema, @graphql-tools/utils and etc.
Check out https://www.graphql-tools.com to learn what package you should use instead
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-server-errors@^2.5.0 The `apollo-server-errors` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023 and October 22nd 2024, respectively). This package's functionality is now found in the `@apollo/server` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-server-plugin-base@^0.14.0 The `apollo-server-plugin-base` package is part of Apollo Server v2 and v3, which are now deprecated (end-of-life October 22nd 2023 and October 22nd 2024, respectively). This package's functionality is now found in the `@apollo/server` package. See https://www.apollographql.com/docs/apollo-server/previous-versions/ for more details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-tracing@^0.16.0 The `apollo-tracing` package is no longer part of Apollo Server 3. See https://www.apollographql.com/docs/apollo-server/migration/#tracing for details
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › apollo-cache-control@^0.15.0 The functionality provided by the `apollo-cache-control` package is built in to `apollo-server-core` starting with Apollo Server 3. See https://www.apollographql.com/docs/apollo-server/migration/#cachecontrol for details.
deprecate @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-core@2.26.1 › graphql-extensions@^0.16.0 The `graphql-extensions` API has been removed from Apollo Server 3. Use the plugin API instead: https://www.apollographql.com/docs/apollo-server/integrations/plugins/
Recently updated (since 2023-08-21): 29 packages (detail see file C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli\node_modules\.recently_updates.txt)
  Today:
    → globby@9.2.0 › @types/glob@7.2.0 › @types/node@*(20.5.7) (08:33:06)
  2023-08-27
    → jscodeshift@0.6.4 › @babel/plugin-proposal-object-rest-spread@7.20.7 › @babel/helper-compilation-targets@7.22.10 › browserslist@4.21.10 › caniuse-lite@^1.0.30001517(1.0.30001524) (13:47:37)
  2023-08-26
    → jscodeshift@0.6.4 › @babel/plugin-proposal-object-rest-spread@7.20.7 › @babel/helper-compilation-targets@7.22.10 › browserslist@4.21.10 › electron-to-chromium@^1.4.477(1.4.503) (06:02:25)
  2023-08-25
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining@7.22.5 › @babel/plugin-transform-optional-chaining@^7.22.5(7.22.12) (16:28:36)
  2023-08-24
    → jscodeshift@0.6.4 › @babel/preset-typescript@^7.1.0(7.22.11) (21:08:53)
    → jscodeshift@0.6.4 › @babel/preset-typescript@7.22.11 › @babel/plugin-transform-modules-commonjs@^7.22.11(7.22.11) (21:08:39)
    → jscodeshift@0.6.4 › @babel/preset-typescript@7.22.11 › @babel/plugin-transform-typescript@^7.22.11(7.22.11) (21:08:47)
    → jscodeshift@0.6.4 › @babel/parser@^7.1.6(7.22.11) (21:08:36)
    → jscodeshift@0.6.4 › @babel/plugin-proposal-class-properties@7.18.6 › @babel/helper-create-class-features-plugin@^7.18.6(7.22.11) (21:08:36)
    → jscodeshift@0.6.4 › flow-parser@0.*(0.215.1) (02:21:32)
    → jscodeshift@0.6.4 › @babel/core@^7.1.6(7.22.11) (21:08:56)
    → jscodeshift@0.6.4 › @babel/core@7.22.11 › @babel/helpers@^7.22.11(7.22.11) (21:08:52)
    → jscodeshift@0.6.4 › @babel/core@7.22.11 › @babel/traverse@^7.22.11(7.22.11) (21:08:47)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-class-static-block@^7.22.5(7.22.11) (21:08:47)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-async-generator-functions@^7.22.10(7.22.11) (21:08:36)
    → jscodeshift@0.6.4 › @babel/preset-typescript@7.22.11 › @babel/plugin-transform-modules-commonjs@7.22.11 › @babel/helper-simple-access@7.22.5 › @babel/types@^7.22.5(7.22.11) (21:08:45)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-dynamic-import@^7.22.5(7.22.11) (21:08:37)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-export-namespace-from@^7.22.5(7.22.11) (21:08:38)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-json-strings@^7.22.5(7.22.11) (21:08:38)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-logical-assignment-operators@^7.22.5(7.22.11) (21:08:38)
    → @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › apollo-server-types@0.10.0 › apollo-server-env@3.2.0 › node-fetch@^2.6.1(2.7.0) (01:18:39)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-modules-systemjs@^7.22.5(7.22.11) (21:08:39)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-nullish-coalescing-operator@^7.22.5(7.22.11) (21:08:39)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-numeric-separator@^7.22.5(7.22.11) (21:08:39)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-object-rest-spread@^7.22.5(7.22.11) (21:08:40)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-optional-catch-binding@^7.22.5(7.22.11) (21:08:40)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-private-property-in-object@^7.22.5(7.22.11) (21:08:47)
    → jscodeshift@0.6.4 › @babel/preset-env@7.22.10 › @babel/plugin-transform-regenerator@7.22.10 › regenerator-transform@0.15.2 › @babel/runtime@^7.8.4(7.22.11) (21:08:41)
  2023-08-23
    → @vue/cli-ui@4.5.19 › apollo-server-express@2.26.1 › @types/express-serve-static-core@^4.17.21(4.17.36) (02:14:02)
All packages installed (842 packages installed from npm registry, used 1m(network 1m), speed 485.17kB/s, json 759(7.85MB), tarball 31.1MB)
[@vue/cli@4.0.3] link C:\Users\yangd\AppData\Roaming\npm\vue@ -> C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli\bin\vue.js

C:\WINDOWS\system32>node -v
v10.16.3

C:\WINDOWS\system32>npm -v
6.9.0

C:\WINDOWS\system32>cnpm -v
cnpm@6.0.0 (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\lib\parse_argv.js)
npm@6.14.18 (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\node_modules\npm\lib\npm.js)
node@10.16.3 (D:\Java_developer_tools\program\nodejs10.16\node.exe)
npminstall@3.28.1 (C:\Users\yangd\AppData\Roaming\npm\node_modules\cnpm\node_modules\npminstall\lib\index.js)
prefix=C:\Users\yangd\AppData\Roaming\npm
win32 x64 10.0.19045
registry=https://registry.npm.taobao.org

C:\WINDOWS\system32>vue -V
@vue/cli 4.0.3

C:\WINDOWS\system32>
~~~

![image-20230828150026377](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828150026377.png)



---

## 7 创建Vue脚手架项目时出错

![image-20230828172256244](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828172256244.png)

~~~
D:\Java_developer_tools\frontweb\my_vue_project>vue init webpack my_vue_project_qs

  Command vue init requires a global addon to be installed.
  Please run npm install -g @vue/cli-init and try again.


D:\Java_developer_tools\frontweb\my_vue_project>npm install -g @vue/cli-init
npm WARN deprecated vue-cli@2.9.6: This package has been deprecated in favour of @vue/cli
npm WARN deprecated consolidate@0.14.5: Please upgrade to consolidate v1.0.0+ as it has been modernized with several long-awaited fixes implemented. Maintenance is supported by Forward Email at https://forwardemail.net ; follow/watch https://github.com/ladjs/consolidate for updates and release changelog
npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142
npm WARN deprecated coffee-script@1.12.7: CoffeeScript on NPM has moved to "coffeescript" (no hyphen)
npm WARN deprecated har-validator@5.1.5: this library is no longer supported
npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.

> metalsmith@2.6.1 postinstall C:\Users\yangd\AppData\Roaming\npm\node_modules\@vue\cli-init\node_modules\metalsmith
> node metalsmith-migrated-plugins.js || exit 0

(node:3660) ExperimentalWarning: The fs.promises API is experimental
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules\@vue\cli-init\node_modules\chokidar\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})

+ @vue/cli-init@5.0.8
added 248 packages from 213 contributors in 126.789s
~~~



---

## 8 在cmd 窗口 退出vue cli 脚手架项目



![image-20230828174354942](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828174354942.png)

---

## 9 vue cli 脚手架项目位置

D:\Java_developer_tools\frontweb\my_vue_project\my_vue_project_qs

---

## 10 在vue 中使用插件 通常要Vue.use() 一下





![image-20230828230152369](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230828230152369.png)

## 11 Vue2 cli 脚手架 的路由文件router/index.js中 alt+enter 自动引入组件

![image-20230829101459422](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230829101459422.png)

![image-20230829101528396](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230829101528396.png)

但是自动引入的是相对路径的 同时后面有个分号  不好，与上面保持一致

改写为import Hsp1 from "@/components/Hsp1" 

![image-20230829101735430](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230829101735430.png)

---

## 12 配置路由时的name属性与组件的名称保持一致 

![image-20230829112550133](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230829112550133.png)

直接去复制

![image-20230829112802341](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20230829112802341.png)

---

## 

## 13 Vue中template中含有了 两个element控件, 因此需要使用 `div`将 `el-tree`和`el-dialog`包起来否则vue会报编译错误



![image-20240304170325371](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240304170325371.png)



![image-20240304170533288](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240304170533288.png)



## 14 Vue.js 中，`ref` 是一个特殊的属性



在 Vue.js 中，`ref` 是一个特殊的属性，当它用在 HTML 元素上时，可以用来给元素或子组件注册引用信息。引用（refs）提供了一种方式来直接访问 DOM 元素或子组件的实例。

在你的代码片段中：

```html
<el-tree
  :data="data"
  show-checkbox
  default-expand-all
  node-key="id"
  ref="tree"
  highlight-current
  :props="defaultProps">
</el-tree>
```

`ref="tree"` 这一行的意思是，你正在为 `<el-tree>` 组件创建一个引用（reference），并将这个引用命名为 "tree"。在 Vue 组件内部，你可以通过 `this.$refs.tree` 来访问这个 `<el-tree>` 组件的实例。这意味着你可以直接调用组件的方法，访问其数据和属性，甚至操作其子 DOM。

例如，如果 `el-tree` 组件有一个方法叫做 `getCheckedNodes()`，你可以在父组件中这样调用它：

```javascript
let checkedNodes = this.$refs.tree.getCheckedNodes();
```

这样，你就可以获取到树形控件中被选中的节点数组。

使用 `ref` 是一种非常强大的功能，因为它允许你直接操作子组件，但它也应该谨慎使用，因为过度依赖 `ref` 可能会使得你的应用更难以维护。它违背了 Vue 数据驱动的设计原则，因此，在可以通过数据和方法实现的情况下，尽量避免使用 `ref`。然而，对于某些特定场景，如需要直接操作 DOM 或调用子组件的方法，`ref` 是非常有用的。



## 15 在 Vue.js 中，方法的对应关系是基于方法名而不是方法签名（即方法的参数）。因此 deleteHandle() 和 deleteHandle(scope.row.id,scope.row.name) 都和方法池中的  deleteHandle (id,name) {} 方法对应



~~~vue
<el-button v-if="isAuth('commodity:brand:delete')" type="danger" @click="deleteHandle()" :disabled="dataListSelections.length <= 0">批量删除</el-button>

<el-button type="text" size="small" @click="deleteHandle(scope.row.id,scope.row.name)">删除</el-button>


<script>
  import AddOrUpdate from './brand-add-or-update'
  export default {
    data () {
      return {
// 上面两个 deleteHandle() 和 deleteHandle(scope.row.id,scope.row.name) 都和下面方法池中的  deleteHandle (id,name) {} 方法对应
      methods: {
       deleteHandle (id,name) {

                	}
          	   }
          	 }  
          	}   
          	     } 
</script>                
                 
                 
                 
~~~

在 Vue.js 中，方法的对应关系是基于方法名而不是方法签名（即方法的参数）。这意味着无论你如何调用一个方法（不管是不带参数，还是带有不同的参数），只要方法名相同，就会调用到同一个方法定义。

在你提供的代码中，存在两种不同的 `deleteHandle` 方法调用方式：

1. **批量删除**：通过 `deleteHandle()` 调用，没有提供任何参数。
2. **单个删除**：通过 `deleteHandle(scope.row.id,scope.row.name)` 调用，提供了两个参数：`id` 和 `name`。

尽管调用方式不同，它们都指向下面方法池中的同一个方法定义：

```javascript
deleteHandle (id, name) {
    // 方法实现
}
```

这是因为 Vue.js 在处理事件绑定时只查看方法名称 `deleteHandle`，而不关心调用时使用了多少参数。在 JavaScript 中，函数参数是灵活的，意味着一个函数可以被调用时传递任意数量的参数，这不会引起错误。如果函数定义时包含参数，但在调用时没有提供相应的参数，这些参数只会被赋值为 `undefined`。

因此，无论是不带参数的 `deleteHandle()` 还是带有两个参数的 `deleteHandle(scope.row.id,scope.row.name)`，它们都会映射到同一个 `deleteHandle` 方法上。在 `deleteHandle` 方法的实现中，可以通过检查参数 `id` 和 `name` 是否存在来区分是哪种调用情况，并相应地执行不同的逻辑处理：

- 如果 `id` 和 `name` 都是 `undefined`（或其他非期望值），那么可以认为是执行批量删除。
- 如果 `id` 和 `name` 有具体的值，那么可以认为是执行针对特定项目的删除操作。

这种设计允许 `deleteHandle` 方法在不同场景下复用，简化代码并提高代码的可维护性。

这种设计允许 `deleteHandle` 方法通过不同的调用形式（有参数调用和无参数调用）来处理不同的删除场景（单个删除和批量删除）。方法内部的逻辑需要根据是否传入参数（以及参数的值）来执行相应的操作，这体现了 JavaScript 函数和 Vue 事件处理器的灵活性。



## 16 Vue的`activated`方法

Vue的`activated`方法是与`keep-alive`组件一起使用时特有的生命周期钩子。当一个被`keep-alive`缓存的组件被激活时，`activated`钩子就会被触发。这通常发生在以下两种情况下：

1. 当组件第一次被缓存显示时，`activated`钩子在组件的`mounted`钩子之后被调用。
2. 当缓存的组件再次被重新插入DOM时，`activated`钩子会被触发，但此时不会再次执行`mounted`钩子。

因此，`activated`钩子在组件的生命周期中大致的位置是在`created`之后，但在两种情况下有所不同：

- 对于初次渲染，`activated`是在`mounted`之后被调用。
- 对于由`keep-alive`缓存的组件，当它们重新被激活时，`activated`是在重新插入DOM后被调用，但不再经过`mounted`过程。

这意味着`activated`钩子适用于需要在组件每次激活时运行的任务，如拉取数据或重置状态。这与`created`和`mounted`钩子不同，这两个钩子只在组件实例被创建和初次插入DOM时分别被调用一次。





在你的Vue组件中，`activated`生命周期钩子仅在使用了`<keep-alive>`时才会被触发。如果你的组件被包裹在`<keep-alive>`标签中，这意味着组件不会被销毁而是保持在内存中，当再次导航回该组件时，它会从缓存中恢复并触发`activated`钩子。

如果你的应用场景包括以下情况之一，那么在`activated`钩子中调用`this.getCategories()`可能是更好的选择：

1. **数据实时性要求高**：如果你的树形菜单数据会频繁更改，每次返回该页面时你都希望显示最新的数据，那么在`activated`中调用`this.getCategories()`可以确保用户每次访问时都能获取到最新的分类数据。

2. **节省资源**：如果组件包含在`<keep-alive>`标签中，当组件不显示时，它不会被销毁。这意味着不需要在每次组件创建时重新获取数据，只有当组件从缓存中恢复时才需要更新数据，这样可以节省网络资源和提高性能。

3. **用户体验**：如果用户期望在返回页面时能看到最新的数据而不是缓存的数据，那么在`activated`中更新数据可以提供更好的用户体验。

如果以上情况与你的使用场景相符，那么可以将`this.getCategories()`放在`activated`生命周期钩子中，以确保每次激活组件时都能获取最新数据。然而，如果你的组件没有被`<keep-alive>`包裹，或者这些情况不适用于你的应用场景，那么就没有必要在`activated`中调用`this.getCategories()`，保持在`created`钩子中即可。

基于你的代码，如果你的组件确实被`<keep-alive>`包裹并且你希望每次访问时都能获取最新的分类数据，你可以这样修改：

```javascript
activated() {
  // 更新分类数据
  this.getCategories();
  // 更新数据列表
  this.getDataList();
},
```

这样，每次组件被激活时，都会刷新分类列表和数据列表。但请注意，**如果组件没有被`<keep-alive>`包裹，这个修改将不会有任何效果。**



让我来解释这一点。在 Vue.js 中，组件的生命周期钩子有几种，两个常见的是 `created` 和 `activated`。但它们的行为和触发时机有所不同，尤其是在结合 `<keep-alive>` 时。

1. **`created` 生命周期钩子**：这个钩子在组件实例被创建后被调用，这发生在模板编译 / 挂载之前。对于不使用 `<keep-alive>` 的普通组件，每当你访问该组件时，`created` 钩子都会被调用，因为每次都是重新创建组件实例。在这个钩子中获取数据可以确保组件每次“创建”时都能加载最新的数据。

2. **`activated` 生命周期钩子**：这个钩子是专门配合 `<keep-alive>` 使用的。当一个组件被 `<keep-alive>` 包裹时，它不会每次都重新创建，而是被保留在内存中。这意味着，组件在首次加载时会经历常规的生命周期，包括 `created` 钩子。但如果你离开这个页面，然后再回来，由于组件被缓存了，它不会重新经历创建过程，因此不会触发 `created` 钩子。相反，它会触发 `activated` 钩子。这就意味着如果你希望每次回到这个组件时都能看到最新数据（即使数据在后台更新了），你应该在 `activated` 钩子中获取这些数据，而不是只在 `created` 中获取。

当我说“如果用户期望在返回页面时能看到最新的数据而不是缓存的数据”，我的意思是：如果你的组件被 `<keep-alive>` 包裹，并且用户希望每次返回该组件时都看到更新过的数据，那么你应该在 `activated` 钩子中重新获取数据，以保证显示的是最新的信息，而不是用户上次访问时缓存的信息。

总结来说：

- 如果没有使用 `<keep-alive>`，那么组件每次访问都是“新的”，`created` 钩子每次都会被调用，你可以在这里获取数据，以确保数据是最新的。
- 如果使用了 `<keep-alive>`，则应使用 `activated` 钩子来确保用户每次返回组件时都能看到最新的数据，因为 `created` 钩子不会在组件从缓存中恢复时被再次调用。

 



## 17 在Vue中 created() 和 activated() 方法的比较

在Vue中：

- `created` 钩子只在组件**初始化创建时调用一次**。这意味着不论组件是否被 `<keep-alive>` 包裹，只要新创建一个组件实例，`created` 钩子就会被触发。但对于同一个组件实例，这个钩子不会再次被调用。

- `activated` 钩子是专门为 `<keep-alive>` 缓存的组件设计的。当一个组件第一次加载时，`activated` 钩子在 `mounted` 钩子之后被调用。之后，每次这个组件从缓存中恢复（即每次它变得可见时），`activated` 钩子都会被触发。这意味着，如果你的页面使用了 `<keep-alive>` 并且用户频繁地切换视图（不是重新加载），`activated` 钩子的触发频率将会更高。

因此，如果你需要确保每次用户访问组件时都能获得最新数据，并且你的组件被 `<keep-alive>` 包裹，那么在 `activated` 钩子中获取数据是一个好主意。这样，你就可以在用户每次返回该组件时获取最新数据，而不是仅仅在组件首次创建时获取。

确实，这种方法可以提高性能，因为：

1. 当组件不显示时，它不会占用额外的处理时间或资源来更新数据。
2. 只有当用户实际需要查看组件时，才会触发数据更新，从而节省了不必要的数据请求。

这样既保证了数据的实时性，又避免了不必要的性能开销。





## 18 在 Vue 中，将某个方法抽取出来作为公共组件



原来的方法：

~~~
<script>
export default {
  methods: {
 // 获取树形菜单分类列表，带层级
    getCategories() {
      //这里的`$http`实际上就是axios,只是在main.js中起了一个别名
      this.$http({
        // 解读这里的url是获取后端分级菜单列表的url地址，即获取带层级的商品分类表`commodity_category`所有数据
        // url: 'http://localhost:9090/commodity/category/list/tree',

        // 请求的url
        // 就是 http://localhost:5050/api/commodity/category/list/tree
        url: this.$http.adornUrl('/commodity/category/list/tree'),
        method: 'get'
      }).then(({data}) => { //这里的{data} 是对象解构，解构了上面url请求后端返回来的数据，
        // responseData对象的data属性
        //输出
        // console.log("getCategories()方法中 .then(({data}) => {..) 返回的data= ", data);
        //返回需要展示的数据 data.data.data
        //如果使用{data}, 得到的要展示的数据使用 data.data 即可，因为解构了一层

        //将后端返回来的数据，绑定到数据池的data属性 注意绑定数据后，页面就会相应地变化！
        this.data = data.data;
      })
    },
    }
    }
</script>
~~~



进行抽取：

在 Vue 中，将某个方法抽取出来作为公共组件使用通常涉及以下几个步骤：

1. **创建一个公共的 JavaScript 文件**：创建一个新的 JS 文件用于存放公共方法。例如，你可以创建一个名为 `categoryService.js` 的文件，用于存放与分类相关的服务方法。

2. **编写公共方法**：在 `categoryService.js` 文件中，定义一个函数，例如 `getCategories`，并导出这个函数。确保这个方法返回一个 Promise，因为你可能需要进行异步操作（如 Axios 请求）。

3. **在组件中导入和使用公共方法**：在你的 Vue 组件中，导入 `categoryService.js` 文件，并在需要的地方调用 `getCategories` 方法。

下面是一个如何实现这一过程的例子：

**1. 创建 `categoryService.js` 文件**：

```javascript
// categoryService.js
import axios from 'axios';

export const getCategories = () => {
  return axios({
    url: 'http://localhost:9090/commodity/category/list/tree',
    method: 'get'
  });
}
```

**2. 在 Vue 组件中使用 `getCategories` 方法**：

在你的 Vue 组件中，导入这个方法并在生命周期钩子或者其他逻辑中调用它：

```vue
<script>
import { getCategories } from './services/categoryService'; // 假设categoryService.js位于services文件夹

export default {
  data() {
    return {
      data: [], //树形菜单的数据
      // 其他数据...
    };
  },
  methods: {
    // 其他方法...

    fetchCategories() {
      getCategories().then(({ data }) => {
        this.data = data.data;
      }).catch(error => {
        console.error('获取分类列表失败', error);
        // 处理错误
      });
    }
  },
  created() {
    this.fetchCategories();
  }
};
</script>
```

在这个例子中，`getCategories` 函数被抽取到 `categoryService.js` 文件中，并在组件中通过 `fetchCategories` 方法使用。这种方式使得 `getCategories` 方法可以在多个组件中重用，减少代码冗余并提高可维护性。





## 19` <button v-on:click="this.count += 2">点击增加+2</button>` ` <button v-on:click="show">点击显示书名~</button> `简单的点击事件和ElementUI中定义好的事件`@node-click="nodeclick"`，传递的值由什么决定

你提出的是一个很好的问题，它涉及到 Vue 事件处理和参数传递的机制，我将为你分开解释以便更清晰地理解：

### 直接在模板中修改数据
在这个例子中：
```html
<button v-on:click="this.count += 2">点击增加+2</button>
```
当按钮被点击时，Vue 将执行 `v-on:click` 中指定的表达式 `this.count += 2`。这里没有传递任何额外的参数给一个方法或函数，因为你直接在模板里进行了操作。这种情况下，`v-on:click` 只是告诉 Vue 当点击发生时要做什么，而不涉及到任何方法调用。

### 调用方法处理事件
另一方面，在这个例子中：
```html
<button v-on:click="show">点击显示书名~</button>
```
当按钮被点击时，Vue 会调用 `show` 方法。如果 `show` 是这样定义的：
```javascript
methods: {
    show() {
        // 一些逻辑
    }
}
```
那么在点击按钮时，`show` 方法将被调用，但没有传递任何参数给它。因为在调用 `show` 方法时，你没有在模板中提供任何参数。

### 事件处理和参数传递
现在，对于你提到的树形控件节点点击事件（`@node-click="nodeclick"`），情况就有所不同。这是因为 `node-click` 事件本身就是设计为当事件触发时传递特定的参数（在 `el-tree` 的情况下，是节点数据、节点对象和节点组件实例）。这是 `el-tree` 组件内部实现的一部分，并且是该组件的事件 API 的一部分。

总结一下，**传递的值由以下因素决定**：

1. **直接在模板操作**：没有传递值，你直接在模板中指定了要执行的操作。
   
2. **调用方法但不传参数**：方法会被调用，但除非方法内部有访问到事件对象等，否则不会接收到外部传递的参数。

3. **组件事件处理器**：当你监听一个组件（如 `el-tree`）的事件时，传递给事件处理器的值（参数）是由该事件决定的。这些参数由事件触发时的组件内部逻辑定义，并自动传递给你的方法。

如果你需要在事件处理器中接收事件对象（例如，常见的 DOM 事件如点击），你可以明确地在方法定义中添加参数，比如 `show(event)`，然后在模板中这样写：`v-on:click="show($event)"`。这样，Vue 将把原生 DOM 事件对象作为参数传递给 `show` 方法。但是，对于自定义事件（如 `node-click`），参数是由该事件的设计者定义的，并且会自动传递给处理函数。



## 20 Vue `<el-popover> `的slot="reference"



~~~
<el-popover placement="right-end" v-model="popCatelogSelectVisible">
        <!-- <category-cascader :catelogPath.sync="catelogPath"></category-cascader>-->
        <!-- 这里我们加入分类的 Cascader 级联选择器, 前面我们使用过 -->
        <el-cascader
          v-model="cascadedCategoryId"
          :options="categories"
          :props="props"></el-cascader>

        <div style="text-align: right; margin: 0">
          <el-button size="mini" type="text" @click="popCatelogSelectVisible = false">取消</el-button>
          <el-button type="primary" size="mini" @click="addBrandCategoryRelation"> 确定</el-button>
        </div>
		<!--当点击`新增关联`按钮时显示el-popover组件中定义的el-cascader 和 div-el-button中的内容 -->
        <el-button slot="reference">新增关联</el-button>
      </el-popover>
~~~

![image-20240321200929094](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240321200929094.png)

在 Vue.js 和 Element UI 的组合中，`slot="reference"` 是在 `<el-popover>` 组件中使用的一个特殊属性，用于定义触发该弹出框的元素。当你在 `<el-popover>` 标签内部使用 `<el-button slot="reference">新增关联</el-button>`，你实际上是在指定这个按钮作为弹出框的触发元素。

这里的 `"reference"` 插槽（slot）起到了“引用”的作用，即它引用或标记了一个元素（在你的例子中是一个按钮），当该元素被点击时，与之关联的 `<el-popover>` 将会显示出来。

### 为什么点击“新增关联”按钮就显示 `<el-popover>` 中的内容？

这是因为 `<el-popover>` 设计之初就是为了提供一个弹出框的功能，该弹出框可以包含任意的HTML内容或Vue组件。当 `<el-popover>` 的 `v-model` 或 `visible` 属性为真（即弹出框应当显示时），弹出框就会出现在页面上。

在你的例子中，当你点击“新增关联”按钮时，由于这个按钮通过 `slot="reference"` 被指定为 `<el-popover>` 的触发元素，Element UI 的内部逻辑会自动将 `<el-popover>` 的 `visible` 属性设置为 `true`，因此弹出框显示出来。

此机制使得开发者可以方便地创建各种交互式弹出框，而无需手动控制它们的显示和隐藏。这也是为什么你只需点击按钮，弹出框就能自动显示出来的原因。

## 21 前端向后端发送请求 有两种携带参数的方式1直接在请求的URL中添加查询参数2使用axios（或其他HTTP库）的params属性



~~~
    getCategoryBrandRelation(){
      this.$http({
        // url: this.$http.adornUrl(`/commodity/categorybrandrelation/brand/list?brandId=${this.brandId}`),

        // 下面这段代码会将 brandId 添加到请求的查询字符串中，这与直接在URL中指定查询参数是等效的。在实际发送请求时，这些参数会附加到URL之后，形式也是 /brand/list?brandId=1。
        // 下面这个请求的请求头为:
        // GET /api/commodity/categorybrandrelation/brand/list?t=1711129443854&brandId=1 HTTP/1.1
        url: this.$http.adornUrl(`/commodity/categorybrandrelation/brand/list`),
        method: 'get',
        //携带的参数
        params: this.$http.adornParams({
          brandId: this.brandId
        })
      }).then(({data}) => {
        // 测试得到的数据
        console.log("data=> ",data)
      })

    },
~~~





在你提供的代码中，前端发送请求的部分有两种携带参数的方式，但实际上只需要一种即可。

后端部分，由于使用了 `@RequestParam("brandId") Long brandId` 来接收参数，这意味着后端期望从请求的查询参数中获取 `brandId` 的值。这是Spring MVC处理HTTP请求中查询参数的标准方式。

前端发送请求时，你确实可以直接在URL中添加查询参数，如 `/commodity/categorybrandrelation/brand/list?brandId=${this.brandId}`。这种方式是符合HTTP标准的，并且与你后端的处理方法相匹配，后端可以通过 `@RequestParam` 正确接收到这个参数。

同时，你的代码中也展示了另一种携带参数的方法，即使用 `params` 属性：

```javascript
params: this.$http.adornParams({
    brandId: this.brandId
})
```

这段代码会将 `brandId` 添加到请求的查询字符串中，这与直接在URL中指定查询参数是等效的。在实际发送请求时，这些参数会附加到URL之后，形式也是 `/brand/list?brandId=1`。

因此，两种方式都可以让后端正确接收到 `brandId` 参数。但在一个请求中同时使用这两种方式是不必要的，可能会导致代码混乱或理解困难。通常，你只需选择其中一种方式即可。如果你通过URL模板设置了参数，就不需要再在 `params` 里设置；反之亦然。

总结来说，你的后端代码设置是可以正常接收前端通过查询参数发送的 `brandId` 的，无论是直接在URL中附加，还是通过请求的 `params` 属性设置。但为了保持代码的清晰和一致性，建议只选择一种方式进行参数传递。

~~~
/**
 * 使用 getCategoryBrandRelation 方法从后端API获取特定品牌和分类的关联记录。
 * 这个方法会发送一个GET请求到后端，请求的URL包含一个查询参数 brandId。
 * 
 * 后端的categoryBrandListByBrandId方法使用@RequestParam注解来接收brandId参数，
 * 这意味着它期望从请求的查询字符串中获取brandId的值。因此，前端需要在请求中提供这个参数。
 * 
 * 在JavaScript中，有两种方式向后端传递brandId参数：
 * 1. 直接在请求的URL中添加查询参数，如 /commodity/categorybrandrelation/brand/list?brandId=${this.brandId}
 *    这种方法直观且符合HTTP请求的标准格式。
 * 
 * 2. 使用axios（或其他HTTP库）的params属性，如：
 *    params: this.$http.adornParams({ brandId: this.brandId })
 *    这会将参数添加到查询字符串中，与直接写在URL中的效果相同。
 * 
 * 注意：虽然两种方法都可以将参数正确传递到后端，但在同一个请求中同时使用这两种方式是不必要的。
 * 建议选择其中一种方式来保持代码的一致性和清晰性。
 * 
 * 示例代码发送GET请求，携带brandId参数，获取与该品牌关联的分类记录：
 * 
 * this.$http({
 *   url: this.$http.adornUrl(`/commodity/categorybrandrelation/brand/list?brandId=${this.brandId}`),
 *   method: 'get',
 *   // 选择以下一种方式携带参数：
 *   // 方式1: 在URL中直接附加参数
 *   // 或
 *   // 方式2: 使用params属性
 *   params: this.$http.adornParams({ brandId: this.brandId })
 * }).then(({data}) => {
 *   console.log("data=> ", data); // 在控制台输出获取到的数据
 * });
 * 
 * 请根据实际情况选择合适的参数传递方式。
 */

~~~



## 22 后端使用 @RequestBody Long[] ids 接收数据，前端也需要使用数组传递数据！





~~~
    // 增加方法，响应删除 品牌和分类关联的处理
    deleteCateRelationHandle(id) {

      // 获取删除的分类 id ,这里之所以将id放到数组中，是因为后端是通过数组进行接收数据的
      // 当你使用 @RequestBody 注解时，Spring会期待接收的是一个完整的请求体，这通常意味着你需要在前端发送一个JSON格式的请求体。在这个例子中，前端应该发送一个如 [1, 2, 3] 的JSON数组，每个元素都是一个要删除的资源的ID。
      // 如果你尝试直接发送单个ID（不是数组），如直接发送数字 1，后端会尝试将这个单个值映射到一个 Long[] 类型，这会导致类型不匹配的错误，因为后端期待的是一个数组而不是单个数字。
      // 因此，在前端调用这个API时，即使你只需要删除一个条目，也应该将这个ID放入一个数组中，如 [1]，然后发送这个数组作为请求体。这样做符合后端期待的数据格式，可以确保后端正确处理请求。
      var ids = id
      // var ids = [id]

      this.$http({
        url: this.$http.adornUrl(`/commodity/categorybrandrelation/delete`),
        method: 'get',
        //携带的参数
        params: this.$http.adornParams({
          id: ids
        })
      }).then(({data}) => {
        // 测试得到的数据
        // console.log("data=> ",data)

        // 刷新 品牌-分类 表格数据
        this.getCategoryBrandRelation()

      })
    },
~~~



~~~java
/**
     * 删除 注意这里前端需要放到数组中再传过来！！
     * 当你使用 @RequestBody 注解时，Spring会期待接收的是一个完整的请求体，这通常意味着你需要在前端发送一个JSON格式的请求体。在这个例子中，前端应该发送一个如 [1, 2, 3] 的JSON数组，每个元素都是一个要删除的资源的ID。
     *
     * 如果你尝试直接发送单个ID（不是数组），如直接发送数字 1，后端会尝试将这个单个值映射到一个 Long[] 类型，这会导致类型不匹配的错误，因为后端期待的是一个数组而不是单个数字。
     *
     * 因此，在前端调用这个API时，即使你只需要删除一个条目，也应该将这个ID放入一个数组中，如 [1]，然后发送这个数组作为请求体。这样做符合后端期待的数据格式，可以确保后端正确处理请求。
     */
    @RequestMapping("/delete")
    // @RequiresPermissions("commodity:categorybrandrelation:delete")
    public R delete(@RequestBody Long[] ids) {
        categoryBrandRelationService.removeByIds(Arrays.asList(ids));

        return R.ok();
    }
~~~





在你的后端代码中，`delete` 方法使用了 `@RequestBody` 注解来接收请求体中的数据。这里，方法期望接收一个 `Long[]` 类型的数组。这意味着前端需要发送一个包含一个或多个长整型（`Long`）ID的数组作为请求体。

当你使用 `@RequestBody` 注解时，Spring会期待接收的是一个完整的请求体，这通常意味着你需要在前端发送一个JSON格式的请求体。在这个例子中，前端应该发送一个如 `[1, 2, 3]` 的JSON数组，每个元素都是一个要删除的资源的ID。

如果你尝试直接发送单个ID（不是数组），如直接发送数字 `1`，后端会尝试将这个单个值映射到一个 `Long[]` 类型，这会导致类型不匹配的错误，因为后端期待的是一个数组而不是单个数字。

因此，在前端调用这个API时，即使你只需要删除一个条目，也应该将这个ID放入一个数组中，如 `[1]`，然后发送这个数组作为请求体。这样做符合后端期待的数据格式，可以确保后端正确处理请求。

例如，如果你使用axios发送请求，你可以这样构造请求体：

```javascript
axios.post('/api/delete', [1, 2, 3]) // 假设你想删除ID为1, 2, 3的条目
    .then(response => {
        // 处理响应
    })
    .catch(error => {
        // 处理错误
    });
```

即使你只有一个ID要删除，也需要将它放入数组中：

```javascript
axios.post('/api/delete', [1]) // 假设你只想删除ID为1的条目
    .then(response => {
        // 处理响应
    })
    .catch(error => {
        // 处理错误
    });
```

这样的前端请求与后端的期望相匹配，能够确保后端正确地处理删除请求。



## 23 URL中添加查询参数的两种形式

当然，下面我将对直接在URL中添加查询参数和使用请求库（如axios）的`params`属性进行对比，以便更清晰地理解两者之间的相似性：

### 1. 直接在URL中添加查询参数：

这种方法是手动将查询参数直接附加到URL的末尾。这通常用于HTTP GET请求，其中查询参数明确地显示在URL中。

- **示例**:

  ```javascript
  // 使用JavaScript的fetch方法
  fetch('/api/items?categoryId=1&status=active')
  ```

  或者在浏览器地址栏直接访问:

  ```
  http://example.com/api/items?categoryId=1&status=active
  ```

在这个示例中，查询参数`categoryId`和`status`直接附加在URL后面。使用这种方法，你需要手动确保参数正确编码以避免URL解析错误。

### 2. 使用请求库（如axios）的`params`属性：

这种方法利用了JavaScript HTTP客户端库（如axios）的功能，这些库提供了构建查询字符串的内置方法。使用库的`params`属性时，你可以以对象的形式提供查询参数，库会自动处理参数的编码和附加到URL。

- **示例**:

  ```javascript
  // 使用axios发送GET请求
  axios.get('/api/items', {
      params: {
          categoryId: 1,
          status: 'active'
      }
  })
  ```

在这个示例中，`categoryId`和`status`被放在一个对象中，并传递给axios的`params`属性。axios自动将这些参数转换成与直接在URL中手动添加相同的查询字符串，并附加到请求的URL上。你不需要手动编码参数，axios会为你处理这些。

### 总结：

两种方式的目的都是为了在发起HTTP请求时传递查询参数。它们的主要区别在于：

- **直接在URL中添加查询参数**：需要手动构造整个URL，包括参数的编码。
- **使用请求库的`params`属性**：参数以键值对形式提供，请求库负责编码和构造完整的URL。

两种方法最终效果相同，都会发送包含查询参数的请求到服务器。选择哪一种方法主要取决于个人偏好以及是否想要利用HTTP库自动处理参数编码和构造的便利性。

## 24 在请求体中传递参数的形式

### 在请求体中发送数据：

- **形式**：数据不在URL中，而是放在请求的body中，通常为JSON格式。
- **示例**：使用POST方法，`axios.post('/api/items/delete', { ids: [1, 2, 3] })`
- **使用场景**：适用于POST、PUT、DELETE等HTTP方法，用于发送数据到服务器，如提交表单数据、上传文件或发送大量数据。
- **特点**：可以发送大量或敏感数据，数据不在URL中，更加安全，不受URL长度限制。

通过请求体发送数据，通常用于POST和PUT请求，适合发送大量数据或包含敏感信息的数据。





请求体（Request Body）通常用于发送较大量的数据或包含敏感信息的数据到服务器，尤其是在使用POST、PUT等HTTP方法时。以下是一些常见的使用请求体发送请求参数的示例：

### 1 使用原生JavaScript的`fetch`方法发送POST请求：

```javascript
fetch('/api/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'John Doe',
        email: 'johndoe@example.com',
    })
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));
```

这里，`body`属性用于发送JSON格式的数据。数据需要先被转换为JSON字符串，然后在请求体中发送。

### 2 使用Axios发送POST请求：

```javascript
axios.post('/api/users', {
    name: 'Jane Doe',
    email: 'janedoe@example.com',
})
.then(response => console.log(response.data))
.catch(error => console.error('Error:', error));
```

在Axios中，我们直接传递一个对象给`axios.post`的第二个参数，Axios会自动将其转换为JSON格式，并设置适当的`Content-Type`头。

### 3 使用Axios发送PUT请求：

```javascript
axios.put('/api/users/1', {
    name: 'Jane Smith',
    email: 'janesmith@example.com',
})
.then(response => console.log(response.data))
.catch(error => console.error('Error:', error));
```

PUT请求通常用于更新资源。在这个例例子中，我们尝试更新ID为1的用户的信息。

### 4 使用jQuery发送POST请求：

```javascript
$.ajax({
    url: '/api/users',
    method: 'POST',
    contentType: 'application/json',
    data: JSON.stringify({
        name: 'Mark Twain',
        email: 'marktwain@example.com',
    }),
    success: function(data) {
        console.log(data);
    },
    error: function(error) {
        console.error('Error:', error);
    }
});
```

在这个示例中，使用jQuery的`$.ajax`方法发送POST请求，并明确设置`contentType`为`application/json`，表明发送的数据类型为JSON。同时，数据也需要被转换成JSON字符串格式。

这些示例展示了在不同前端环境中如何使用请求体发送数据。无论使用哪个库或方法，核心概念都是将需要发送的数据放置在请求体（request body）中，并在需要时设置正确的内容类型（Content-Type），如`application/json`。



## 25 vue 中 的 watch: {  cascadedCategoryId(path) { // 监控到数据池中 cascadedCategoryId 的变化     console.log("路径=", path); }  watch是监控的数据池里的变量cascadedCategoryId 吗？如何监控到的？通过方法名？

在 Vue 中，`watch` 用于观察 Vue 实例上的数据变化，然后运行一些特定的代码响应这些变化。在你提供的代码片段中，`watch` 监听的是 `cascadedCategoryId` 这个属性。

当你在 `watch` 里定义了一个与 Vue 实例（或组件实例）的数据属性同名的函数（在这个例子中是 `cascadedCategoryId`），Vue 会自动监视这个指定的数据属性。一旦这个属性的值发生变化，Vue 就会调用对应的函数。

这里是如何工作的：

1. `cascadedCategoryId` 应该是定义在 Vue 实例的 `data` 返回的对象中，或者是一个计算属性。

2. 在 `watch` 对象内，你定义了一个和 `data` 中的 `cascadedCategoryId` 同名的方法。这意味着，每当 `cascadedCategoryId` 的值有变化时，Vue 会自动调用这个方法。

3. 在这个方法内部，你可以获取到新的值（在这里通过参数 `path` 接收）。这个参数表示变化后的新值。你可以在这个方法内做一些响应数据变化的操作，比如，打印新的值，调用 API，更新其他数据等。

4. `console.log("路径=", path);` 这行代码会在 `cascadedCategoryId` 每次更新时执行，并且打印出它的新值。

注意：如果你要监视的是一个对象或数组，Vue 无法检测到对象属性的添加或删除。因此，如果 `cascadedCategoryId` 是一个对象或数组，且你想要检测到里面属性的变动，那么你可能需要在 watch 选项中进行深度监听（通过设置 `deep: true`），或者使用 Vue.set 方法来更新对象或数组。

简单来说，是的，通过 `watch` 对象里的方法名来匹配需要监视的数据属性，一旦匹配的属性值发生变化，对应的方法就会被执行。

## 26 如果你要监视的是一个对象或数组，Vue 无法检测到对象属性的添加或删除。 但是如果只是数据更新也是可以监控到的对吗？`console.log("路径=", path); 这行代码会在 cascadedCategoryId 每次更新时执行，并且打印出它的新值。`依然生效

是的，你的理解是正确的。Vue 可以检测到对象或数组中已存在属性的变化，比如修改一个数组的某一项或更改对象的某一个属性的值。但是，Vue 默认情况下无法检测到对象新添加的属性或从对象中删除的属性，以及直接通过索引添加或删除数组项（如 `arr[0] = 'newItem'` 或 `delete arr[0]`）。

如果你有一个如下的对象：

```javascript
data() {
  return {
    cascadedCategoryId: {
      id: 1,
      name: 'Category 1'
    }
  }
}
```

并且你使用 `watch` 来监视 `cascadedCategoryId`：

```javascript
watch: {
  'cascadedCategoryId': {
    handler(newVal, oldVal) {
      console.log('新路径=', newVal);
    },
    deep: true
  }
}
```

在这种情况下，如果你更改了 `cascadedCategoryId.id` 或 `cascadedCategoryId.name` 的值，Vue 会检测到这些变化，因为它们是对象上已存在的属性。所以，每当 `cascadedCategoryId` 的 `id` 或 `name` 属性更新时，上面的监视器都会执行，并且打印出新的 `cascadedCategoryId` 对象。

但是，如果你给 `cascadedCategoryId` 添加了一个全新的属性，比如通过执行 `this.cascadedCategoryId.newProp = 'New Property'`，默认情况下这个变化是不会被 `watch` 检测到的。如果你需要监视整个对象包括其新增属性，你应该在 `watch` 中设置 `deep: true` 来进行深度监听。不过，请注意，深度监听会稍微消耗更多的性能，因为它需要递归遍历所有属性。

在实践中，对于数组，如果你使用 Vue 的方法如 `push()`, `pop()`, `shift()`, `unshift()` 或 `splice()`，Vue 可以检测到这些变更。对于对象，如果需要添加新属性并使之响应式，应使用 `Vue.set(this.cascadedCategoryId, 'newProp', 'New Property')` 来代替直接赋值。



## 27  `<el-select>`  的前端校验 触发方式是`trigger: 'change'`

是的，你的观察是对的。在 Vue 中，`trigger: 'blur'` 触发方式意味着校验将在输入框失去焦点时触发。对于 `<el-select>` 组件，用户选择一个选项通常不会导致元素失去焦点，因此 `blur` 事件并不会触发校验。这就是为什么你在选择了一个选项后，错误提示没有消失的原因。

为了修复这个问题，你可以将校验触发条件从 `blur` 改为 `change`，这样每次选项改变时就会触发校验。这对于下拉选择框（如 `<el-select>`）是更加合适的触发方式。修改后的代码如下：

```javascript
dataRule: {
  // ... 其他校验规则
  attrType: [
    { required: true, message: '属性类型[0-销售属性，1-基本属性]不能为空', trigger: 'change' }
  ],
  // ... 其他校验规则
}
```

通过这样修改，每当用户改变 `<el-select>` 组件的值时，都会立即触发校验，从而可以及时清除或显示错误消息。确保对所有适用的表单元素（比如其他的 `<el-select>`）应用这种改变，这样可以保持表单校验的一致性和及时性。

是的，将校验规则的 `trigger` 设置为 `'blur,change'` 是可以的。这样做会让校验在两种情况下触发：当用户离开（即“失去焦点”）该输入字段时，以及当用户更改选项时。这可以为你提供更灵活的校验方式，确保无论用户是如何与表单交互，校验都能被触发。

修改后的校验规则会像这样：

```javascript
dataRule: {
  // ... 其他校验规则
  attrType: [
    { required: true, message: '属性类型[0-销售属性，1-基本属性]不能为空', trigger: 'blur,change' }
  ],
  // ... 其他校验规则
}
```

这样设置后，无论用户是在选项上选择后立即移开（触发 `change`），还是在没有更改选择的情况下移开（触发 `blur`），校验都将被执行。这确保了表单在用户与之交互时能够正确地反馈校验结果。

## 28 this.$refs['dataForm'].resetFields() 会重置表单在数据池中的数据

如果一个表单项有初始值，并且通过 `v-model` 与 `dataForm` 中的某个属性绑定，那么调用 `resetFields()` 方法时，这个表单项将会被重置到它的初始值。

**注意:使用 `this.$refs['formRef'].resetFields()` 方法可以重置表单，但仅限于已通过 `prop` 属性绑定的字段。 如果没有通过 `prop` 属性绑定`dataForm`中的属性，则该`dataForm`中的对应属性不会重置为初始值！**

### 问题背景

在使用 Element UI 的 Vue 应用中，你遇到了一个表单重置的问题。表单包含多个字段，其中包括“所属分类”（`categoryId`）和“所属分组”（`attrGroupId`）。在实现表单的新增功能时，希望通过点击“新增”按钮后，能够重置表单中的所有字段到初始状态。

### 发现的问题

1. 当点击“新增”按钮以打开一个新的表单对话框时，预期是所有表单字段都重置为其初始值。
2. 实际上，“所属分类”字段能够正确重置，但“所属分组”字段却没有按预期重置。

### 问题原因

1. 在 Element UI 中，`<el-form-item>` 的 `prop` 属性是用来定义表单项的验证规则和将表单项绑定到数据模型的键。如果一个表单项没有指定 `prop` 属性，那么在调用 `resetFields()` 方法时，它不会被重置到初始值。
2. 在你的代码中，最初“所属分组”(`attrGroupId`) 的 `<el-form-item>` 没有设置 `prop` 属性，因此，即使调用了 `resetFields()` 方法，这个字段也没有被重置。

### 解决方案

为“所属分组”字段的 `<el-form-item>` 添加 `prop="attrGroupId"` 属性：

```html
<el-form-item label="所属分组" prop="attrGroupId">
  <el-select ref="groupSelect" v-model="dataForm.attrGroupId" placeholder="请选择">
    <el-option
      v-for="item in attrGroups"
      :key="item.id"
      :label="item.name"
      :value="item.id"></el-option>
  </el-select>
</el-form-item>
```

通过这样的改变，`attrGroupId` 字段被纳入表单的管理范围内。现在，每次调用 `this.$refs['dataForm'].resetFields()` 时，`attrGroupId` 也会被重置为其在 `dataForm` 中的初始值。

### 总结

1. 在使用 Element UI 构建表单时，确保为每个需要验证和重置的表单项设置正确的 `prop` 属性。
2. `prop` 属性值应与绑定的数据模型中的键相匹配。
3. 使用 `this.$refs['formRef'].resetFields()` 方法可以重置表单，但仅限于已通过 `prop` 属性绑定的字段。
4. 正确设置 `prop` 属性不仅有助于表单重置，还有助于表单验证和数据绑定的正确执行。

## 29 Element UI 的 `<el-select>` 组件进行表单校验使用`trigger: 'change'`



~~~
<el-form-item label="属性类型[0-销售属性，1-基本属性]" prop="attrType">
        <!--      <el-input v-model="dataForm.attrType" placeholder="属性类型[0-销售属性，1-基本属性]"></el-input>-->

        <!--将属性 el-input输入框类型 改成 el-select 控件-->
        <!--        <el-form-item label="属性类型" prop="attrType">-->
        <!-- <el-input v-model="dataForm.attrType" placeholder="属性类型[0-销售属性，
        1-基本属性，2-既是销售属性又是基本属性]"></el-input>-->
        <el-select v-model="dataForm.attrType" placeholder="请选择">
          <el-option
            label="基本属性"
            :value="1">
          </el-option>
          <el-option
            label="销售属性"
            :value="0">
          </el-option>
        </el-select>
        <!--        </el-form-item>-->

      </el-form-item>
      
      
dataRule: {
       
        attrType: [
        
          // {required: true, message: '属性类型[0-销售属性，1-基本属性]不能为空', trigger: 'blur,change'} 这个不行
          
          
          {required: true, message: '属性类型[0-销售属性，1-基本属性]不能为空', trigger: 'change'} 这个行
        ],
      
~~~



### 问题概述：

你在使用 Element UI 的 `<el-select>` 组件进行表单校验时遇到了一个问题。即使你的代码看起来没有错误，`<el-select>` 组件的动态校验却不如预期工作。这表现为当用户改变选择时，表单校验没有正确触发。

### 问题原因：

1. **触发事件不匹配**：在 Element UI 中，不同的表单控件可能需要不同的事件来正确触发校验。对于 `<el-select>` 组件，由于它不像输入框那样具有 `blur`（失去焦点）事件，仅依靠 `blur` 事件来触发校验可能不足以覆盖所有用户交互情况。

2. **校验规则设置**：原始设置中校验规则的 `trigger` 属性被设置为 `'blur,change'`，意图是在元素失去焦点或内容改变时进行校验。但对于下拉选择组件来说，`blur` 事件并不总是在用户做出选择后立即触发，这可能导致校验反应不及时或不触发。

### 解决方案：

将校验规则的 `trigger` 属性从 `'blur,change'` 修改为仅 `'change'`。这样可以确保每次用户更改 `<el-select>` 的选项时都会触发校验，从而确保表单状态正确更新。

### 实施步骤：

1. 更新校验规则：

   ```javascript
   dataRule: {
     attrType: [
       { required: true, message: '属性类型[0-销售属性，1-基本属性]不能为空', trigger: 'change' }
     ],
     // 其他校验规则...
   }
   ```

2. 确保 `<el-select>` 组件绑定了正确的 `v-model` 并在选项更改时更新。

### 总结：

在使用 Element UI 进行表单校验时，了解不同控件的事件和行为是非常重要的。特别是，校验触发器 `trigger` 应根据实际的控件类型和预期的用户交互来选择。对于下拉选择框 `<el-select>`，使用 `'change'` 作为校验触发器通常比使用 `'blur'` 更为有效，因为它能够确保用户每次选择都会触发校验，从而保持表单状态的准确和及时更新。

# 3 es6 箭头函数

## 3.1 箭头函数注意事项

箭头函数是ES6中引入的一种新的函数写法，它相比于传统的函数表达式更简洁。但在使用箭头函数的简写形式时，有一些注意点需要考虑：

1. **没有自己的`this`**：箭头函数不绑定自己的`this`，它会捕获其所在上下文的`this`值作为自己的`this`值，因此在使用时要注意`this`的指向。

2. **没有`arguments`对象**：箭头函数没有自己的`arguments`对象，但是可以通过剩余参数(`...args`)来访问函数的参数。

3. **不能使用`new`操作符**：箭头函数不能用作构造器，不能使用`new`关键字，否则会抛出错误。

4. **没有`prototype`属性**：由于不能使用`new`关键字，箭头函数也就没有`prototype`属性。

5. **不能用作生成器函数**：箭头函数不能使用`yield`关键字，因此不能用作生成器函数。

6. **单行表达式的隐式返回**：如果箭头函数的函数体只包含一条语句，可以省略大括号并且自动返回该语句的结果。如果要返回一个对象字面量，必须在对象字面量外面加上括号。

7. **语法简洁**：箭头函数允许省略圆括号当只有一个参数时，但是如果没有参数或有多个参数，还是需要圆括号。

8. **不适合所有场合**：由于`this`的绑定规则不同，箭头函数可能不适用于所有情况，比如当需要动态上下文或在对象方法和构造函数中使用时。

记住这些注意点可以帮助您更有效地使用箭头函数，并避免在编程时出现常见的错误。

## 3.2 解释`如果要返回一个对象字面量，必须在对象字面量外面加上括号`

在箭头函数中，当你想要直接返回一个对象字面量时，你需要在对象字面量外面加上括号。这是因为大括号 `{}` 在 JavaScript 中既可以表示代码块，也可以表示对象字面量的开始和结束。

如果你直接在箭头函数后使用大括号，JavaScript 会解释这些大括号为开始和结束一个代码块，而不是表示一个对象。因此，如果没有任何返回语句，那么函数不会返回任何值。

为了避免这种情况，当你想要返回一个对象字面量，你应该将它包裹在圆括号 `()` 中。这样，JavaScript 解释器就能正确地理解你想要返回的是一个对象，而不是一个代码块。

举个例子：

不正确的方式（JavaScript 将解释大括号为代码块）:

```javascript
let getObj = () => { key: 'value' }; // 这将不会正常工作
```

正确的方式（使用圆括号来返回对象）:

```javascript
let getObj = () => ({ key: 'value' }); // 这将返回一个对象
```

在这个正确的例子中，箭头函数会返回一个对象，包含一个键为 `key` 且值为 `'value'` 的属性。通过使用圆括号，我们明确地告诉 JavaScript 解释器，大括号内部的内容应该被视为一个对象字面量，而不是一个新的代码块。

# 4 不是程序发生异常才进入到catch中吗？Promise对象分别进入到.then()和.catch()执行的时机是？

不是。

在 JavaScript 的 `Promise` 对象中，`.then()` 和 `.catch()` 方法被用于处理异步操作的成功结果和失败结果：

1. **`.then()`**：当 `Promise` 被成功解决（或"fulfilled"）时，`.then()` 方法中的回调函数将被调用。这通常表示异步操作已成功完成，并且可以通过 `.then()` 方法中的回调函数获取到操作的结果。

2. **`.catch()`**：当 `Promise` 被拒绝（或"rejected"）时，`.catch()` 方法中的回调函数将被调用。这通常表示异步操作失败或出现错误。`Promise` 被拒绝可以由于多种原因，包括手动拒绝（例如，在 `Promise` 内部通过调用 `reject()` 函数）、抛出异常（在 `Promise` 的执行函数或 `.then()` 方法的回调函数中抛出错误）。

~~~
 // 将 重复的代码提取出来 封装成一个方法
        function get(url,data){

          return new Promise((resolve,reject) => {
                $.ajax({
                    url:url,
                    data:data,
                    success(resultData){
                        //console.log(resultData);
                        resolve(resultData);
                    },
                    error(err){
                        //console.log(err);
                        reject(err);
                    }
                })
            })
        }


        get("data/monster.json").then((resultData) => {
        //下面这种写法也可以
        //get("http://localhost:57823/es6/my_es6/promise/data/monster.json").then((resultData) => {
           console.log("第1次请求数据=",resultData);
           return get(`data/monster_detail_${resultData.id}.json`);
        }).then((resultData)=>{
            console.log("第2次请求数据=",resultData);
            return get(`data/monster_gf_${resultData.gfid}.json`); //这里是一个promise对象，
            // 所以最后的catch 可以捕获到 这里出现的异常！！
        }).then((resultData)=>{
            console.log("第3次请求数据=",resultData);
            // 这里没有返回promise对象 但是后面的代码不会出错，只是这里出现的异常不会被catch捕获到
        }).catch((err)=>{
            console.log("promise 请求出现异常",err);
        })

~~~







在 `this.$confirm` 的情况中，它使用 `Promise` 来处理用户的交互：

- 当用户点击“确定”按钮时，`$confirm` 的 `Promise` 被解决，这导致 `.then()` 方法中的回调函数被执行。这里，并不是因为程序没有异常就进入 `.then()`，而是因为对话框的逻辑是当用户确认操作时，视为流程“成功”，从而进入 `.then()`。

- 当用户点击“取消”按钮或关闭对话框时，`$confirm` 的 `Promise` 被拒绝，这导致 `.catch()` 方法中的回调函数被执行。在这种情况下，进入 `.catch()` 并不意味着程序发生了异常，而是因为按照 `Element UI` 的 `$confirm` 方法的约定，取消操作会拒绝 `Promise`。

因此，在 `Promise` 的上下文中，"成功" 和 "失败" 并不总是指程序的执行没有错误，而是指异步操作的结果符合或不符合预期。在 `this.$confirm` 的场景中，"成功" 和 "失败" 只是代表用户是确认还是取消了对话框中的操作。

~~~
<script>
export default {
  data() {
    return {
      data: [],
      defaultProps: { //property:属性  树形菜单默认的支持数据 需要和返回的数据格式和属性名对应
        children: 'childrenCategories', //这里是返回的子分类集合节点名,不能乱写,否则，只会显示一级分类
        label: 'name' //取出 name 显示, 可以参考 elementUI 树形控件规则
      }
    };
  },
  methods: {
    append(data) { //处理点击添加分类
      //输出data观察数据结构
      console.log("data=> ", data)
    },
    remove(node, data) { //处理点击删除分类
      //输出node,data观察数据结构
      console.log("node=> ", node, " data=> ", data)
      //这里我们可以参考前面写过的代码来完成删除任务
      //1. 使用数组获取删除的分类的id
      var ids = [data.id]
      //2. 发送请求，完成删除
      //这里的`$http`实际上就是axios,只是在main.js中起了一个别名

      /*
      this.$confirm 在这段代码中并不是一个 axios 对象，而是一个由 Element UI 提供的方法，用于显示确认对话框。这是 Element UI 的一部分，一个基于 Vue 的桌面端组件库。$confirm 方法用于弹出一个模态对话框，询问用户是否确定执行某个操作，并且它返回一个 Promise 对象。
      在 JavaScript 中，Promise 对象用于表示未来某个将要完成（或失败）的异步操作的结果。当 this.$confirm 被调用时，它会显示一个带有确定和取消按钮的对话框。如果用户点击“确定”，Promise 将会被“解决”（resolve），执行 .then() 里的回调函数；如果用户点击“取消”，Promise 将会被“拒绝”（reject），执行 .catch() 里的回调函数。
      因此，当你看到 this.$confirm(...).then(...).catch(...) 这样的代码，它并不是说 $confirm 是一个 axios 请求，而是说 $confirm 返回的是一个可以链式调用 .then() 和 .catch() 方法的 Promise 对象。这样的设计让你可以编写代码来处理用户点击对话框中按钮后的逻辑。
       */
      this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        //确定删除 进行删除操作
        this.$http({
          // 解读这里的url是获取后端分级菜单列表的url地址，即获取带层级的商品分类表`commodity_category`所有数据
          url: 'http://localhost:9090/commodity/category/delete',
          method: 'post',
          //发出请求时携带的数据，参考 src/views/modules/sys/role.vue:158
          data: this.$http.adornData(ids, false)
        }).then(({data}) => { //这里的{data} 是对象解构，解构了上面url请求后端返回来的数据，
          // responseData对象的data属性
          //输出
          console.log("remove(node, data)方法 .then(({data}) 返回的data= ", data);
          //返回需要展示的数据 data.data.data
          //如果使用{data}, 得到的要展示的数据使用 data.data 即可，因为解构了一层

          //将后端返回来的数据，绑定到数据池的data属性
          // this.data = data.data;
          //刷新分类列表 绑定数据
          this.getCategories();
        }).catch(() => {
          //取消了，不做任何操作
        })

      })


    },
    // 获取分类列表，带层级
    getCategories() {
      //这里的`$http`实际上就是axios,只是在main.js中起了一个别名
      this.$http({
        // 解读这里的url是获取后端分级菜单列表的url地址，即获取带层级的商品分类表`commodity_category`所有数据
        url: 'http://localhost:9090/commodity/category/list/tree',
        method: 'get'
      }).then(({data}) => { //这里的{data} 是对象解构，解构了上面url请求后端返回来的数据，
        // responseData对象的data属性
        //输出
        console.log("返回的data= ", data);
        //返回需要展示的数据 data.data.data
        //如果使用{data}, 得到的要展示的数据使用 data.data 即可，因为解构了一层

        //将后端返回来的数据，绑定到数据池的data属性 注意绑定数据后，页面就会相应地变化！
        this.data = data.data;
      })
    },
  },
  created() {//vue生命周期方法，这里经常发出ajax请求

    // 这个阶段组件的 data 和 methods 中的方法已初始化结束，可以访问，但是 dom 结构未
    // 初始化，页面未渲染
    // 老师说明：在这个阶段，经常会发起 Ajax 请求
    this.getCategories();
  }
};
</script>
~~~

# 5 es6 Promise 



是的，您的理解是正确的。当您在 `Promise` 构造器中调用 `resolve(data);` 时，您实际上是设置了 `Promise` 的成功值为 `data`。但是，这个 `data` 并不会自动变为 `policy` 函数的返回值。而是，当 `policy` 函数返回的 `Promise` 被解决（fulfilled）时，`data` 将作为该 `Promise` 解决的值。

要获取这个 `data`，您需要在 `policy()` 调用后面链式调用一个 `.then()` 方法。在 `.then()` 方法的回调函数中，您可以访问到传递给 `resolve` 的 `data`。这个回调函数的参数就是 `data`。换句话说，您确实需要在 `.then()` 中才能取出 `data` 的值。

下面是如何操作的示例：

```javascript
policy().then((data) => {
    // 这里的 data 就是你在 policy 函数里通过 resolve(data) 传递出来的数据
    console.log(data); // 现在可以访问和使用这个 data 了
}).catch((error) => {
    // 如果过程中有任何错误发生（比如网络问题，服务器问题等），就会进入这里
    console.error(error);
});
```

在这个例子中，`.then((data) => {...})` 里面的 `data` 就是从 `policy()` 函数中 `resolve(data)` 传递出来的数据。所以，是的，您需要使用 `.then()` 来“取出”或访问这个数据。



## 如果默认情况又是如何的呢？即没有指定resolve(data);时

## 

如果在 Promise 构造器内部没有明确地调用 `resolve(someValue);`，那么该 Promise 的行为将如下：

1. **Promise 未被解决（未被fulfill）**：如果您从未调用 `resolve()`，那么由该 Promise 构造器创建的 Promise 将永远处于待定（pending）状态，除非您调用了 `reject()`。这意味着任何挂在这个 Promise 上的 `.then()` 或 `.catch()` 回调都不会被执行，因为这个 Promise 没有被解决（fulfill）也没有被拒绝（reject）。

2. **没有返回值**：如果您调用了 `resolve()` 但没有提供任何值（即 `resolve();` 而不是 `resolve(someValue);`），那么 Promise 将会被解决，但是它解决的值将会是 `undefined`。这意味着在后续的 `.then((value) => {...})` 回调中，`value` 将会是 `undefined`。

举例来说，如果您的 `policy` 函数或类似的 Promise 使用如下所示：

```javascript
function exampleFunction() {
    return new Promise((resolve, reject) => {
        // 假设这里是一些异步操作...
        resolve();  // 没有指定任何值
    });
}

exampleFunction().then((result) => {
    console.log(result); // 这将输出 'undefined'，因为没有为resolve()指定值
}).catch((error) => {
    console.error(error); // 如果有错误发生，会进入这里
});
```

在这个例子中，因为 `resolve()` 被调用时没有提供任何参数，所以 `result` 的值会是 `undefined`。

总结，如果您没有指定 `resolve(data);` 时：
- 如果您根本没有调用 `resolve()`，Promise 将永远保持待定状态，不会执行任何 `.then()` 或 `.catch()`。代码中有一行注释为**"// 如果没有写resolve(resultData); p.then() 不会生效"**
- 如果您调用了 `resolve()` 但没有提供参数，Promise 将被解决，但解决的值会是 `undefined`，这个 `undefined` 值将传递给后续的 `.then()`。



```
之所以可以调用promise对象的then函数 是因为在上面ajax请求的success 函数中调用了 resolve(resultData);如果没有写resolve(resultData); p.then() 不会生效
```

## 



当然，下面我将使用 Markdown 格式来详细总结关于 JavaScript `Promise` 和 `resolve()` 方法的信息：

---

### Promise 和 resolve() 方法

#### 1. **Promise 基础**

`Promise` 是 JavaScript 中用于处理异步操作的对象。它代表一个可能现在还不可用但将来某一时刻可能会变得可用的值。`Promise` 对象有三种状态：

- `pending`（待定）：初始状态，既不是成功，也不是失败。
- `fulfilled`（已解决）：意味着操作成功完成。
- `rejected`（已拒绝）：意味着操作失败。

#### 2. **使用 resolve()**

在 `Promise` 构造函数内部，`resolve(value)` 方法被用来将 `Promise` 的状态从 `pending` 变为 `fulfilled`。当 `resolve()` 被调用时：

- 如果 `resolve()` 调用时带有参数，如 `resolve(data);`，则该 `Promise` 将被解决，并将 `data` 作为解决的值。
- 如果 `resolve()` 调用时没有参数，如 `resolve();`，则该 `Promise` 同样会被解决，但解决的值将是 `undefined`。

#### 3. **获取 Promise 结果**

要获取 `Promise` 的结果，我们通常会使用 `.then()` 方法。该方法接受两个参数：一个是当 `Promise` 被解决时要调用的函数，另一个是当 `Promise` 被拒绝时要调用的函数（可选）。

```javascript
// 示例
myPromise.then((value) => {
    // 这里的 value 将是 myPromise 被 resolve 时传递的值
    console.log(value);
}, (error) => {
    // 如果 myPromise 被 reject，将执行这里的代码
    console.error(error);
});
```

#### 4. **示例代码**

```javascript
// 定义一个返回 Promise 对象的函数
function get(url, data) {
    return new Promise((resolve, reject) => {
        $.ajax({
            url: url,
            data: data,
            success(result) {
                resolve(result); // 请求成功，解决 Promise，result 作为解决的值
            },
            error(err) {
                reject(err); // 请求失败，拒绝 Promise，err 作为拒绝的理由
            }
        });
    });
}

// 使用示例
get('api/data.json').then((result) => {
    console.log('请求成功:', result);
}).catch((error) => {
    console.log('请求失败:', error);
});
```

在上面的示例中，`get` 函数发起一个 AJAX 请求，并返回一个 `Promise` 对象。如果 AJAX 请求成功，`resolve(result)` 被调用，`result` 是从服务器返回的数据；如果请求失败，则调用 `reject(err)`。

---

通过上面的总结，您应该对 `Promise` 和 `resolve()` 方法有了更深入的理解。



# 6 之所以可以调用promise对象的then函数 是因为在上面ajax请求的success 函数中调用了 resolve(resultData);

## 如果没有写resolve(resultData); p.then() 不会生效

是的，您的理解是正确的。当您在 `Promise` 的构造器中使用 `resolve(resultData);` 时，这会导致 `Promise` 的状态从 `pending`（等待中）变为 `fulfilled`（已解决），并且 `resultData` 将作为该 `Promise` 解决的值。只有当 `Promise` 被解决（fulfilled）或被拒绝（rejected）时，通过 `then()` 或 `catch()` 注册的回调函数才会被执行。

如果您没有在异步操作成功完成时调用 `resolve(resultData);`（例如，在 AJAX 请求的 `success` 回调中），那么由该 `Promise` 构造的 `Promise` 对象将永远保持 `pending` 状态，因此注册到该 `Promise` 上的 `then()` 方法中的回调函数将不会被执行。

```javascript
let p = new Promise((resolve, reject) => {
    // 异步操作，例如 AJAX 请求
    $.ajax({
        url: 'someUrl',
        success(resultData) {
            // 必须调用 resolve 来改变 Promise 的状态为 fulfilled，使得 then() 中的回调得以执行
            resolve(resultData);
        },
        error(err) {
            // 调用 reject 来改变 Promise 的状态为 rejected，使得 catch() 中的回调得以执行
            reject(err);
        }
    });
});

// 使用 Promise
p.then((data) => {
    // 这里处理解决的结果
    console.log(data);
}).catch((error) => {
    // 这里处理拒绝的原因
    console.error(error);
});
```

在这个例子中，`p.then()` 中的回调函数只有在 `resolve(resultData);` 被调用后才会执行。如果 `resolve(resultData);` 从未被调用，则 `then()` 中的回调函数不会执行，`Promise` 将保持 `pending` 状态。

# 7 cors 前端中一般是跨域问题吗？

是的，CORS（Cross-Origin Resource Sharing，跨来源资源共享）问题通常出现在前端开发中，尤其是当你的网页尝试从不同源（域名、协议或端口）的服务器上请求资源时。浏览器出于安全考虑，默认禁止跨源 HTTP 请求，这就是所谓的"同源策略"。

当你尝试从前端代码（如 JavaScript）中访问另一个源（域名、协议或端口不同）的资源时，如果对方的服务器没有返回适当的 CORS 头来允许请求，浏览器就会拦截这个请求，导致跨域问题。

为了解决这个问题，资源的提供者需要在服务器上设置适当的 CORS 响应头，比如 `Access-Control-Allow-Origin`，来明确允许某些域名进行资源访问。如果你控制着资源的服务器，你可以通过配置这些响应头来解决跨域问题。如果你不控制资源服务器，你可能需要联系服务器的管理员，或者寻找其他方法来获取数据，例如使用JSONP（如果支持的话），或者通过你自己的服务器中转请求。

# 8Vue插槽机制实例



## 1 根据当前行的图片url，取出图片，进行展示 scope.row.logo

```vue
<el-table
  :data="dataList"
  border
  v-loading="dataListLoading"
  @selection-change="selectionChangeHandle"
  style="width: 100%;">
  <el-table-column
    type="selection"
    header-align="center"
    align="center"
    width="50">
  </el-table-column>
  <el-table-column
    prop="id"
    header-align="center"
    align="center"
    label="id">
  </el-table-column>
  <el-table-column
    prop="name"
    header-align="center"
    align="center"
    label="品牌名">
  </el-table-column>
    
    
  <el-table-column
    prop="logo"
    header-align="center"
    align="center"
    label="logo">
      
    <!--使用插槽机制,给表格的列插入 template，显示logo图片-->
    <template slot-scope="scope">
      <img :src="scope.row.logo">
    </template>
  </el-table-column>

```

## 2  根据当前行scope.row，取出当前行的 isshow 的值scope.row.isshow

```vue
    <el-table
      :data="dataList"
      border
      v-loading="dataListLoading"
      @selection-change="selectionChangeHandle"
      style="width: 100%;">
      <el-table-column
        type="selection"
        header-align="center"
        align="center"
        width="50">
      </el-table-column>
      <el-table-column
        prop="id"
        header-align="center"
        align="center"
        label="id">
      </el-table-column>
      <el-table-column
        prop="name"
        header-align="center"
        align="center"
        label="品牌名">
      </el-table-column>
      <el-table-column
        prop="logo"
        header-align="center"
        align="center"
        label="logo">
        <!--使用插槽机制,给表格的列插入 template，显示logo图片-->
        <template slot-scope="scope">
          <img :src="scope.row.logo">
        </template>
      </el-table-column>
      <el-table-column
        prop="description"
        header-align="center"
        align="center"
        label="说明">
      </el-table-column>
      <el-table-column
        prop="isshow"
        header-align="center"
        align="center"
        label="显示">

        <!--引入自定义的内容，使用template和插槽机制
        1. 使用插槽机制，给表格的列加入一个 template , 这可以参考 ElementUI-Table 表格-自定义列模板的代码
        2. 在 template 中替换成 el-switch 控件，参考 ElementUI-Switch 开关-基本用法
        3. v-model="scope.row.isshow" 动态绑定当前行的 isshow 的值
        4. active-color / inactive-color 是激活和未激活的颜色
        5. active-value="1" 激活状态的值，和数据库表isShow字段对应
        6. inactive-value="0" 未激活状态的值，和数据库表isShow字段对应
        7. @change="changeIsShow(scope.row)" 当switch控件状态切换时，会触发changeIsShow(scope.row)
           ，而且我们把 当前行数据scope.row传递到该方法
        -->
        <template slot-scope="scope">
          <!--引入el-switch
          绑定v-model到一个Boolean类型的变量。可以使用active-color属性与inactive-color属性来设置开关的背景色。
          scope.row.isshow 通过插槽机制获取到当前行，然后再获取到isshow

          el-switch 组件使用了 v-model 指令绑定到 scope.row.isshow。这意味着当开关的状态改变时，
          scope.row.isshow 的值会自动更新。

          el-switch 组件有两个重要的属性：active-value 和 inactive-value。
          active-value 定义了当开关处于激活状态时对应的值，在你的代码中设置为 "1"。
          inactive-value 定义了当开关处于非激活状态时对应的值，在你的代码中设置为 "0"。
          当用户点击开关改变它的状态时，如果开关被激活，scope.row.isshow 将被设置为 "1"
          （active-value 的值）。如果开关被关闭，scope.row.isshow 将被设置为 "0"
          （inactive-value 的值）。



          注意:
          :active-value="1"：这里的冒号表示 active-value 的值应该被解释为 JavaScript 表达式，因此传递给 active-value 的是数字 1。
          :inactive-value="0"：同样，这里的冒号表示 inactive-value 的值应该被解释为 JavaScript 表达式，因此传递给 inactive-value 的是数字 0。
          如果不加冒号：

          active-value="1"：没有冒号，Vue 会把这里的 1 解释为字符串 "1" 而不是数字。
          inactive-value="0"：同样，没有冒号，0 会被解释为字符串 "0"。
          -->
          <el-switch
            v-model="scope.row.isshow"
            @change="changeIsShow(scope.row)"
            :active-value="1"
            :inactive-value="0"
            active-color="#13ce66"
            inactive-color="#ff4949">
          </el-switch>

        </template>

      </el-table-column>
      <el-table-column
        prop="firstLetter"
        header-align="center"
        align="center"
        label="检索首字母">
      </el-table-column>
      <el-table-column
        prop="sort"
        header-align="center"
        align="center"
        label="排序">
      </el-table-column>
      <el-table-column
        fixed="right"
        header-align="center"
        align="center"
        width="150"
        label="操作">
          
          
        <template slot-scope="scope">
          <el-button type="text" size="small" @click="addOrUpdateHandle(scope.row.id)">修改</el-button>
<!--          <el-button type="text" size="small" @click="deleteHandle(scope.row.id)">删除</el-button>-->
          <el-button type="text" size="small" @click="deleteHandle(scope.row.id,scope.row.name)">删除</el-button>
        </template>
          
          
          
      </el-table-column>
    </el-table>
```



# 9 图片的css样式只设置宽度style="width: 80px"，图片就会按照比例进行缩小

```
<!--使用插槽机制,给表格的列插入 template，显示logo图片
style="width: 80px", 这里图片的样式只设置宽度，图片就会按照比例进行缩小展示
不需要再指定图片的高度，否则图片有可能会变形
-->
<template slot-scope="scope">
  <img :src="scope.row.logo" style="width: 80px">
</template>
```

# 10 

















