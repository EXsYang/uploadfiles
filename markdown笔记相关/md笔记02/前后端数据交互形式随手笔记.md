# 注解@RequestParam Map<String, String> params 的使用



1 在Spring MVC中，使用`@RequestParam Map<String, String> params`可以接收前端发出的请求参数并将它们作为一个`Map`收集起来。这种方式非常灵活，可以处理来自前端的各种数据提交形式。以下是一些常见的前端数据发送方式，它们都可以被`@RequestParam Map<String, String> params`成功接收和处理：

### 1. 查询字符串（Query String）

这是最常见的GET请求数据传输方式。例如：

```
GET /endpoint?param1=value1&param2=value2
```

在这种情况下，`Map`将包含键值对`"param1" -> "value1"`和`"param2" -> "value2"`。

### 2. 表单数据（Form Data）

当使用POST请求提交表单数据时（`Content-Type: application/x-www-form-urlencoded`），例如：

```
POST /endpoint
Content-Type: application/x-www-form-urlencoded

param1=value1&param2=value2
```

`@RequestParam Map<String, String> params`同样可以捕获这些参数并将它们存入`Map`。

### 3. AJAX请求

使用JavaScript发出的AJAX请求，无论是GET还是POST（当Content-Type被设置为`application/x-www-form-urlencoded`），发送的查询字符串或表单数据都可以被接收。例如，使用jQuery的`$.ajax`方法：

```javascript
$.ajax({
  url: '/endpoint',
  method: 'POST',
  contentType: 'application/x-www-form-urlencoded',
  data: {
    param1: 'value1',
    param2: 'value2'
  }
});
```

### 注意事项

- 当使用`@RequestParam Map<String, String> params`时，所有请求参数都会被包含在`Map`中，但这种方法仅限于接收简单的键值对，并不适用于复杂结构如JSON对象或XML。
- 对于JSON类型的数据（`Content-Type: application/json`），你不能使用`@RequestParam Map<String, String> params`来接收。在这种情况下，应使用`@RequestBody`注解配合一个POJO或者`Map`来接收JSON数据。
- 如果请求中包含数组或列表类型的参数，如`param=arrayValue1&param=arrayValue2`，通过`Map`只能获取到其中的一个值（通常是最后一个）。若需要处理这种类型的参数，可以使用`@RequestParam List<String>`或`@RequestParam String[]`。
- `@RequestParam`是可选的，如果方法参数是`Map<String, String>`（或`MultiValueMap<String, String>`）类型，Spring MVC默认会将HTTP请求参数映射到该参数。

使用`@RequestParam Map<String, String> params`是处理HTTP请求参数的一种灵活方式，适用于需要访问多个请求参数但又不想为每个参数单独声明方法参数的情况。

# 2 注解@RequestParam可以用来接收form表单提交的数据吗？前面为什么提到使用发出Post请求

是的，使用`@RequestParam Map<String, String> params`可以接收通过表单提交的数据。当提到使用POST请求的原因是，表单提交通常以POST方法进行，尤其是当表单数据包含大量信息或包含敏感信息（如密码）时，因为POST方法不会将数据暴露在URL中，从而提供了更好的隐私保护。

表单数据通常以`application/x-www-form-urlencoded`的媒体类型提交，这意味着表单数据被编码为键值对，就像URL的查询字符串一样。这种数据格式可以通过`@RequestParam`直接接收，不论是映射到具体的方法参数还是聚合到`Map<String, String>`中。

### 表单提交示例

假设你有一个HTML表单：

```html
<form action="/submitForm" method="post">
  <input type="text" name="username" />
  <input type="password" name="password" />
  <button type="submit">Submit</button>
</form>
```

当用户填写此表单并点击提交时，浏览器会向`/submitForm`发送一个POST请求，其中包含了输入的用户名和密码。在Spring MVC的控制器中，可以这样接收数据：

```java
@PostMapping("/submitForm")
public String handleSubmit(@RequestParam Map<String, String> params) {
    String username = params.get("username");
    String password = params.get("password");
    // 处理数据...
    return "resultPage";
}
```

这里，`@RequestParam Map<String, String> params`会收集表单中所有的输入字段（input）作为键值对。然后你可以通过键名访问特定的值。

### 为什么提到POST请求

- **安全性**：与GET请求相比，POST请求不会将数据直接暴露在URL中，适合提交敏感信息。
- **数据大小**：理论上，POST请求的数据大小没有限制，适合提交大量数据。
- **适用性**：表单提交是创建或更新资源的常见方式，POST方法语义上适用于这些操作。

尽管使用`@RequestParam Map<String, String> params`可以接收表单数据，但对于复杂的表单或当你需要将表单数据直接映射到一个Java对象时，推荐使用`@ModelAttribute`注解，这样可以更方便地处理表单数据。



# 3 data:{mobile:,password:} 对应后端JavaBean



![image-20240419222423231](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240419222423231.png)





![image-20240419223323952](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240419223323952.png)



注意前端发送的json对象的属性名要和后端JavaBean对象的属性名一致才会封装成功



~~~javascript
  $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function (data) {
                if (data.code == 200) {
                    alert(data.message)
                } else {
                    alert(data.message)
                }
            },
            error: function () {
                alert("失败");
            }
        });
~~~





~~~java
package com.hspedu.seckill.vo;

import lombok.Data;

/**
 * @author yangda
 * @create 2024-04-19-16:12
 * @description: 接收用户登录时，发送的信息 (mobile,password)
 */
@Data
public class LoginVo {

    
    private String mobile;
    private String password;

}

~~~



~~~java
    @RequestMapping("/doLogin")
    @ResponseBody //加上该注解，就不会被解析为视图了。即不会按照templates的视图，而是返回json数据
    public RespBean doLogin(LoginVo loginVo,
                            HttpServletRequest request,
                            HttpServletResponse response){

    log.info("{}",loginVo);

        return RespBean.success(); //默认请求转发到templates/login.html
    }

~~~





# 4 当后端使用`@ResponseBody`返回一个Long类型的数据给前端，前端接收到参数JavaScript能够正确地将Long类型的数据转换为数字，因此你可以放心地使用`if (data.obj > 0) {`这种比较方法。

**其中`data.obj`就是Long类型的数据**

理解和处理从后端传递的Long类型数据在前端的情况需要考虑多个方面，包括后端如何处理数据、前端如何接收数据以及数据在前端的处理方式。接下来，我将详细整理这些方面，并给出相应的代码示例。

实际上，JavaScript处理从后端返回的Long类型数据时，是在解析JSON格式数据时进行的类型转换。由于JSON中并没有显式的类型声明，因此在JavaScript中解析后的数据类型可能会根据其值的大小和格式而自动转换为数字类型。这种转换是JavaScript引擎自动完成的，而不是严格意义上的“正确转换”。

在前端接收到JSON格式数据后，JavaScript引擎会根据其值的特征自动将其转换为适当的类型。对于表示整数的值，如果其范围在JavaScript能够表示的整数范围内，那么它会被转换为数字类型。因此，即使后端返回的数据是Long类型，在前端通过AJAX接收并解析后，其类型可能会被转换为数字类型，从而可以使用数字的比较方法进行处理。

### 后端处理：

1. **Controller层**：在Controller层，通常使用`@ResponseBody`注解将方法返回的对象直接转换为JSON格式的响应数据发送给前端。如果返回的数据是Long类型，则会自动转换为对应的JSON格式。

   ```java
   @RequestMapping("/seckillResult")
   @ResponseBody
   public RespBean getSeckillResult(User user, Long goodsId){
       Long seckillResult = orderService.getSeckillResult(user, goodsId);
       return RespBean.success(seckillResult);
   }
   ```

### 前端接收和处理：

1. **AJAX请求**：前端通过AJAX请求从后端获取数据，通常使用JSON格式接收响应数据。Long类型数据在JSON中会被转换为相应的数字类型。

   ```javascript
   $.ajax({
       url: '/seckillResult',
       type: 'POST',
       data: {
           user: userId,
           goodsId: goodsId
       },
       success: function(data) {
           // 处理从后端返回的Long类型数据
           if (data.obj > 0) {
               // 执行某些操作，表示数值大于0
           } else if (data.obj == 0) {
               // 执行某些操作，表示数值等于0
           } else if (data.obj == -1) {
               // 执行某些操作，表示数值等于-1
           } else {
               // 执行某些操作，表示其他情况
           }
       },
       error: function() {
           // 处理请求失败情况
       }
   });
   ```

2. **数据类型处理**：前端接收到的Long类型数据可以直接用于数值比较，JavaScript会自动将其转换为数字类型。可以使用比较运算符（`>`、`==`、`===`）来判断数值的大小或相等关系。

### 示例说明：

假设后端返回的JSON数据格式如下：

```json
{
  "code": 200,
  "obj": 12345 //这里是Long类型，转换为json后的结果
}
```

在前端接收到这个数据后，可以这样处理：

```javascript
success: function(data) {
    // 处理从后端返回的Long类型数据
    if (data.obj > 0) {
        // 执行某些操作，表示数值大于0
    } else if (data.obj == 0) {
        // 执行某些操作，表示数值等于0
    } else if (data.obj == -1) {
        // 执行某些操作，表示数值等于-1
    } else {
        // 执行某些操作，表示其他情况
    }
}
```

这样，在前后端数据交互过程中，Long类型数据能够被正确处理和比较，保证了数据的准确性和可靠性。

# 5 