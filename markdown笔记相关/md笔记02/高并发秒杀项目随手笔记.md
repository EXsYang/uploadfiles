# 1 数据库基字符集为什么选择utf8mb4?

![image-20240418162025413](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240418162025413.png)



# 2 在 MyBatis 中，JavaBean 属性名和数据库字段名的映射非常关键，正确设置这一映射是保证数据正确封装到 JavaBean 中的前提。以下是 MyBatis 映射机制的详细解释：

### 1. 默认映射行为

如果在 MyBatis 的 `<resultMap>` 中没有明确指定映射关系，MyBatis 默认采用属性名与字段名相同的规则来自动匹配。这意味着，JavaBean 的属性名必须与数据库表的字段名完全一致（包括字母的大小写），否则这些字段将无法被正确封装，其对应的属性值会是 `null`。

例如，如果数据库中的字段名为 `wife_name`，而 JavaBean 中的属性名为 `wifeName`，不使用 `<result>` 指定映射关系的话，`wifeName` 属性将会得到 `null` 值。

### 2. 指定映射关系

为了解决字段名与属性名不一致的问题，可以在 `<resultMap>` 中使用 `<result>` 标签明确指定映射关系。例如：

```xml
<resultMap id="resultWifeMap" type="Wife">
    <result property="wifeName" column="wife_name"/>
</resultMap>
```

这样配置后，`wife_name` 字段的值就会正确地映射到 `wifeName` 属性上。

### 3. MyBatis Plus 的自动映射扩展

MyBatis Plus 是 MyBatis 的一个扩展框架，它提供了更加强大的映射功能，包括自动的驼峰命名转换（即自动将数据库中的下划线分隔命名转换为 JavaBean 中的驼峰式命名）。这意味着，在 MyBatis Plus 中，即便不通过 `<resultMap>` 明确指定映射关系，`wife_name` 也能自动映射到 `wifeName` 属性。

### 4. 总结

- **MyBatis**: 需要属性名和字段名完全一致，或者通过 `<resultMap>` 明确指定映射关系。
- **MyBatis Plus**: 提供自动的驼峰命名转换，更加灵活。

在实际开发中，建议根据具体需求选择合适的工具和配置。如果是在使用标准的 MyBatis，确保你的 `<resultMap>` 配置正确，或者调整数据库字段名和 JavaBean 属性名使其一致。如果希望有更自动化的映射支持，可以考虑使用 MyBatis Plus。



# 3 关于在springboot+thymeleaf的项目中Controller层什么情况下使用的是thymeleaf，返回HTML页面,什么情况下返回的是Json数据的说明



在使用 Spring Boot 构建的项目中，如果你想实现前后端分离并向前端返回 JSON 数据，这实际上与是否包含 `spring-boot-starter-thymeleaf` 依赖并没有直接关系。`spring-boot-starter-thymeleaf` 是一个用于视图模板渲染的依赖，主要用于服务端渲染页面。如果你的项目是前后端分离的，即便保留了这个依赖，也可以轻松返回 JSON 数据。下面是如何做到这一点的详细解释：

### 1. 控制器方法返回 JSON

要使 Spring Boot 控制器返回 JSON 数据，确保你的控制器方法返回的是对象或对象集合，而不是视图名称（字符串）。Spring Boot 使用 `Jackson` 库自动将对象序列化为 JSON 格式。这是标准的做法，如下所示：

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;
import java.util.Arrays;

@RestController
public class UserController {

    @GetMapping("/users")
    public List<User> getAllUsers() {
        return Arrays.asList(
            new User(1, "Alice"),
            new User(2, "Bob")
        );
    }
}
```

在这个例子中，使用 `@RestController` 注解确保所有响应都默认以 JSON 形式返回，无需特别指定响应类型。如果使用的是 `@Controller` 注解，那么需要在方法上使用 `@ResponseBody` 注解来指示方法返回的是响应体内容。

### 2. 关于 `spring-boot-starter-thymeleaf`

你不需要移除 `spring-boot-starter-thymeleaf` 依赖来支持 JSON 数据的返回。这个依赖主要是用于处理 HTML 视图的，如果你的控制器决定了返回类型为非视图（如直接返回数据模型），Spring Framework 的 `DispatcherServlet` 将会根据上下文返回相应的内容。也就是说，即使 `thymeleaf` 在项目中，只要你的方法标记为返回数据（通过 `@RestController` 或 `@Controller`+`@ResponseBody`），返回的就是 JSON 格式的数据。

### 3. 保留 Thymeleaf 的原因

如果你的项目中还需要渲染一些服务器端页面，或者需要生成电子邮件内容等，保留 Thymeleaf 是有意义的。只要适当管理你的控制器和返回类型，就可以在同一个应用中同时支持 HTML 视图渲染和 JSON 数据响应。

### 4. 示例控制器同时支持 Thymeleaf 和 JSON

如果你想在同一个项目中同时使用 Thymeleaf 渲染页面和返回 JSON 数据，可以如下配置控制器：

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MixedController {

    // 返回 Thymeleaf 页面
    @GetMapping("/greeting")
    public String greeting(Model model) {
        model.addAttribute("name", "World");
        return "greeting"; // 返回的是视图名
    }

    // 返回 JSON 数据
    @GetMapping("/data")
    @ResponseBody
    public Map<String, String> getData() {
        Map<String, String> data = new HashMap<>();
        data.put("key", "value");
        return data; // 返回的是 JSON 对象
    }
}
```

### 总结

保留 `spring-boot-starter-thymeleaf` 对返回 JSON 没有影响。选择返回 JSON 或 HTML 视图取决于你的控制器方法的配置，而不是依赖于是否包含某个特定的依赖。这种灵活性是 Spring Boot 提供的一大优点，使得开发者可以根据项目需要灵活选择技术方案。



## 3.2 这里的重点就是是否有@ResponseBody注解对吗？也就是说如果返回即使是String类型的数据，只要有这个注解，也不会按照thymeleaf的方式返回？

是的，您完全正确。在 Spring Boot 中，决定响应类型（即是返回 HTML 页面还是 JSON 数据）的关键是 `@ResponseBody` 注解的使用，以及控制器是否被标记为 `@RestController`（等同于在每个方法上使用 `@Controller` 和 `@ResponseBody`）。让我们具体解释一下这两者如何影响响应内容：

### @ResponseBody 注解

当你在一个控制器方法上使用 `@ResponseBody` 注解时，你告诉 Spring Boot 你希望返回的数据应该直接写入 HTTP 响应体中，而不是被解释为视图名称。这意味着即使方法返回的是字符串，这个字符串也会被当作 HTTP 响应的内容返回，而不会去解析为视图模板路径。例如：

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class SimpleController {

    @GetMapping("/text")
    @ResponseBody
    public String getText() {
        return "Just a plain text";  // 直接返回文本字符串
    }
}
```

在上面的代码中，即使返回值是一个简单的字符串 `"Just a plain text"`，这个字符串也会直接作为响应体返回给客户端，而不会被当作视图名来处理。

### @RestController 注解

`@RestController` 注解是 `@Controller` 和 `@ResponseBody` 的简写。它表明：
- 类中的所有方法都应该将其返回值直接写入响应体中。
- 不需要为每个方法单独声明 `@ResponseBody`。

这适用于 RESTful 服务控制器，其中每个操作都是资源状态的操作，通常需要返回 JSON 或 XML 等非页面形式的数据。例如：

```java
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.GetMapping;

@RestController
public class ApiController {

    @GetMapping("/number")
    public Integer getNumber() {
        return 42;  // 返回数字，自动转换为JSON格式的数字
    }
}
```

在这个例子中，方法 `getNumber()` 返回的整数 `42` 会自动被转换为 JSON 格式，并作为 HTTP 响应体返回。

### 使用 Thymeleaf

保留 `spring-boot-starter-thymeleaf` 依赖是完全无害的，因为是否使用 Thymeleaf 渲染视图完全由控制器方法是否返回视图名称（且没有 `@ResponseBody`）决定。如果你有某些页面需要服务器端渲染，你可以在相应的控制器方法中返回视图名称：

```java
@Controller
public class ViewController {

    @GetMapping("/welcome")
    public String getWelcomePage(Model model) {
        model.addAttribute("message", "Welcome to our site!");
        return "welcome";  // 返回视图名，由 Thymeleaf 处理并渲染
    }
}
```

在这里，`getWelcomePage` 方法返回一个视图名 `"welcome"`，Spring 将使用 Thymeleaf 或其他配置的视图解析器来渲染这个视图模板。

### 总结

因此，无论是返回 JSON 还是渲染视图，关键在于方法的注解配置（`@ResponseBody` 或 `@RestController` vs. `@Controller`），而不是依赖于是否包含 `spring-boot-starter-thymeleaf`。这允许 Spring Boot 应用同时支持 RESTful API 和服务端页面渲染，灵活适应不同的应用场景。



# 4 在HTML中，当点击类型为`button`的按钮时，默认行为是提交其父`<form>`表单（如果没有指定`type`，则`button`默认为`type="submit"`）。这意味着如果按钮在一个表单中，点击它将会导致表单数据被提交到表单的`action`属性指定的URL（如果未指定`action`，则提交到当前页面）。

~~~html
 <form class="more-padding" id="loginForm" method="post" autocomplete="off">
     <input style="background-color: darkgrey;" id="mobile" name="mobile"
                           type="text" placeholder="手机号码"
                           required="true"/>
      <input style="background-color: darkgrey;" id="password" name="password"
                           type="password" placeholder="密码" required="true"/>
     <button class="button sumbit" onclick="login()">Login</button>
 </form>


<script>
    function login() {
        doLogin();
    }

    function doLogin() {
        //得到用户在登录表单填写的密码
        var inputPass = $("#password").val();
        //客户端盐 Dz7Oyf9b
        var salt = g_passsword_salt;
        var str = "" + salt.charAt(0) + inputPass + salt.charAt(6);
        var password = md5(str);

        // console.log("inputPass-->",inputPass)
        // console.log("salt-->",salt)
        // console.log("password-->",password)


        $.ajax({
            url: "/login/doLogin",
            type: "POST",
            data: {
                mobile: $("#mobile").val(),
                password: password
            },
            success: function (data) {
                if (data.code == 200) {
                    alert(data.message)
                } else {
                    alert(data.message)
                }
            },
            error: function () {
                alert("失败");
            }
        });
    }
</script>
~~~



点击“Login”按钮导致发出两次请求的原因通常与表单提交的行为以及JavaScript事件处理有关。在您提供的代码示例中，`<button>`元素的默认行为（提交表单）与通过JavaScript显式触发的行为（调用`login()`函数）可能都在执行，导致请求被发送两次。下面是具体的分析和解决方法：

### 分析问题

1. **HTML表单提交**：在HTML中，当点击类型为`button`的按钮时，默认行为是提交其父`<form>`表单（如果没有指定`type`，则`button`默认为`type="submit"`）。这意味着如果按钮在一个表单中，点击它将会导致表单数据被提交到表单的`action`属性指定的URL（如果未指定`action`，则提交到当前页面）。

2. **JavaScript事件触发**：在您的代码中，点击按钮还会通过`onclick="login()"`触发`login()`函数。这个函数进一步调用`doLogin()`，后者执行了另一个数据提交操作，即通过jQuery的`$.ajax`方法异步提交数据。

### 问题结果

因为同时存在表单默认提交和`$.ajax`提交，所以每次点击“Login”按钮时，会发送两个请求：
- 一个是表单的默认提交。
- 另一个是由`$.ajax`在`doLogin()`函数中发起的异步请求。

### 解决方法

为了防止表单的默认提交行为并确保只通过`$.ajax`发送数据，您可以修改`login()`函数，使其在被调用时阻止默认行为。这可以通过几种方法实现：

#### 方法1: 修改按钮类型
将按钮的`type`属性设置为`button`，这样它就不会触发表单提交：

```html
<button class="button submit" type="button" onclick="login()">Login</button>
```

#### 方法2: 在`login()`中阻止默认行为
在`login()`函数中添加一个事件参数，并调用`preventDefault()`来阻止默认行为：

```html
<button class="button submit" onclick="login(event)">Login</button>
```

```javascript
function login(event) {
    event.preventDefault();  // 阻止表单默认提交行为
    doLogin();
}
```

#### 方法3: 直接在`<form>`标签上处理提交事件
移除按钮的`onclick`事件，并在表单上设置`onsubmit`：

```html
<form class="more-padding" id="loginForm" method="post" autocomplete="off" onsubmit="return doLogin()">
    <input style="background-color: darkgrey;" id="mobile" name="mobile" type="text" placeholder="手机号码" required="true"/>
    <input style="background-color: darkgrey;" id="password" name="password" type="password" placeholder="密码" required="true"/>
    <button class="button submit" type="submit">Login</button>
</form>
```

```javascript
function doLogin() {
    var inputPass = $("#password").val();
    var salt = g_passsword_salt;  // 确保这个变量是正确定义并可用的
    var str = "" + salt.charAt(0) + inputPass + salt.charAt(6);
    var password = md5(str);

    $.ajax({
        url: "/login/doLogin",
        type: "POST",
        data: {
            mobile: $("#mobile").val(),
            password: password
        },
        success: function (data) {
            if (data.code == 200) {
                alert(data.message);
            } else {
                alert(data.message);
            }
        },
        error: function () {
            alert("登录失败");
        }
    });

    return false;  // 阻止表单默认提交行为
}
```

选择以上任何一种方法都可以避免双重提交的问题。通常，我推荐方法3，因为它保留了表单的语义性（使用`<form>`的`submit`事件），同时清晰地管理了提交行为。



# 5 JavaBean中属性参数校验方式(两种)



## 第一种通过自定义校验器 + 自定义注解的方式完成校验



![image-20240420185041842](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240420185041842.png)



## 第二种 直接将参数校验的逻辑写在业务代码中 完成校验



![image-20240420185315630](https://raw.githubusercontent.com/EXsYang/PicGo-images-hosting/main/images/image-20240420185315630.png)





# 6 您提到的问题关注于如何在Spring框架中处理数据返回流程，特别是在异常处理和模板渲染时如何“脱离”常规的`Controller->Service->Controller`流程。让我们详细探讨这两种情况：

### 1. 全局异常处理的数据返回流程

在Spring框架中，全局异常处理通常是通过`@ControllerAdvice`或`@RestControllerAdvice`配合`@ExceptionHandler`实现的。这种处理机制可以“脱离”常规的业务逻辑流程（即`Controller->Service->Controller`），直接在异常发生时处理并返回响应。

#### **工作原理**

- 当在服务层或控制器层抛出异常时，而这些异常没有在当前层次被捕获处理，则会向上冒泡到Dispatcher Servlet。
- 如果配置了全局异常处理器(`@ControllerAdvice`类)，Spring会查找是否有匹配的`@ExceptionHandler`方法可以处理这个异常。
- 一旦找到合适的处理方法，就会直接调用此方法来处理异常，并构建响应返回给客户端，这个过程中不会回到原来的控制器方法。

#### **示例解释**

考虑以下全局异常处理器定义：

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler({ArithmeticException.class, NullPointerException.class, AccessException.class})
    public String handlerAritException(Exception e, Model model, HandlerMethod handlerMethod){
        model.addAttribute("msg", e.getMessage());
        return "error/global";  // 指向错误页面的视图名
    }
}
```

这里的方法`handlerAritException`直接返回视图名，这意味着：

- **异常信息传递**：异常信息被放入`Model`，这样错误页面可以使用这些信息。
- **非传统请求转发**：返回的是视图名称，而不是重定向或转发路径，Spring MVC会处理这个返回值，并渲染对应的视图（HTML页面），然后返回渲染后的HTML页面给客户端。
- **拦截器不干预**：这个处理过程中，常规的Spring MVC拦截器不会介入处理异常响应的生成，因为拦截器主要拦截正常的控制器执行流程。

### 2. Thymeleaf模板的请求转发

当使用Thymeleaf或其他模板引擎时，视图解析过程本质上也是一种请求内部处理，但它与传统的Servlet请求转发有所不同：

- **视图解析**：当控制器返回一个视图名时，视图解析器（如Thymeleaf视图解析器）会根据这个视图名找到相应的模板文件，然后执行模板渲染。
- **直接返回渲染结果**：模板引擎处理完毕后，生成的HTML内容直接作为响应体返回给客户端，这个过程没有新的HTTP请求发生，因此不同于传统的HTTP重定向或请求转发。

### 总结

这两种“脱离”常规`Controller->Service->Controller`流程的方法各有特点：
- **全局异常处理**：提供一种集中处理应用程序中所有异常的方式，能够直接构造响应或定向到错误页面，简化了异常管理并提升了用户体验。
- **模板渲染（如Thymeleaf）**：允许控制器直接返回视图名称，由框架内部处理模板渲染并返回HTML，适用于服务端渲染页面的应用场景。

这些机制都是Spring框架提供的强大功能，旨在简化开发流程、提升应用的灵活性和响应效率。



# 7 在Spring和Spring Boot应用中，`@Valid` 和 `@Validated` 都用于触发数据验证，但它们在使用和支持的功能方面有所不同。下面是这两个注解的主要用法和区别，帮助你选择适合特定场景的注解。

### @Valid

`@Valid` 是由 JSR-303 和 JSR-349 Bean Validation API 定义的标准验证注解。它可以用于任何Java Bean对象上，以触发对其属性的验证约束。

**使用场景**：
- 应用在方法参数上（如控制器方法中的参数），以确保传入的参数满足定义的约束。
- 可以用在类型级别、属性级别或方法参数级别。
- 常用在Spring MVC的控制器或JAX-RS中。

### @Validated

`@Validated` 是由Spring框架提供的，作为`@Valid`的一个增强版，支持分组功能。它可以在Spring管理的Bean中使用，不仅限于验证控制器参数，还可以应用于Spring管理的任何Bean。

**使用场景**：
- 支持分组验证，允许在验证时指定一组特定的约束。例如，可以定义一些验证规则仅在创建时应用，而另一些规则仅在更新时应用。
- 可用于方法级别和类型级别。
- 常用于Spring服务或组件中，特别是当你需要在不同的上下文中应用不同的验证规则时。

### 示例解析

在你的示例中，使用了`@Valid`来确保传入的`LoginVo`对象满足验证约束：

```java
@RequestMapping("/doLogin")
@ResponseBody
public RespBean doLogin(@Valid LoginVo loginVo,
                        HttpServletRequest request,
                        HttpServletResponse response) {
    log.info("{}", loginVo);
    return userService.doLogin(loginVo, request, response);
}
```

这里`@Valid`用于控制器方法参数`loginVo`，确保在执行`doLogin`方法体之前，`loginVo`已通过验证（例如，检查是否包含有效的手机号码和密码格式）。如果`loginVo`中的数据不符合`@IsMobile`等注解定义的规则，将自动拒绝处理请求，并生成一个响应表示输入错误。

### 选择 @Valid 还是 @Validated？

- 如果你需要在控制器层简单地验证模型数据，且不需要分组功能，使用`@Valid`即可。
- 如果你需要更复杂的验证逻辑，例如分组验证或在Spring组件之外进行验证（如在服务层），应选择`@Validated`。

通常，在Spring MVC控制器中，`@Valid` 已经足够用于处理大部分常规的数据验证需求。当你的验证需求超出这些基本场景，或者当你想要利用分组特性来执行更细致的控制时，`@Validated`是一个更好的选择。



## 2 需要分组，此时就不可以使用@Valid了对吗

是的，正如你的示例所示，当你需要进行分组验证时，应使用 `@Validated` 而不是 `@Valid`。这是因为 `@Valid` 注解不支持验证分组功能，它将对所有应用了验证约束的字段进行验证，而无法区分场景。而 `@Validated` 注解支持分组功能，使得你可以根据不同的场景应用不同的验证规则。

### 分组验证的使用场景

分组验证通常在以下情况下非常有用：

- **创建与更新操作**：在创建新记录（如新品牌）时，可能所有字段都需要被验证，但在更新记录时，某些字段（如品牌ID）可能不允许更改，因此不需要验证。
- **条件验证**：在不同的操作或业务逻辑分支中，可能需要对同一对象的不同字段集进行验证。

### 示例说明

在你的代码中：

```java
@RequestMapping("/save")
public R save(@Validated(SaveGroup.class) @RequestBody BrandEntity brand) {
    // 业务逻辑
}
```

这里使用 `@Validated(SaveGroup.class)` 表明在处理 `save` 方法时，只对 `BrandEntity` 实体中属于 `SaveGroup` 这一验证组的属性进行验证。这种方式非常适合处理实体在不同操作（如新增与更新）中的验证需求。

### 关于 @Valid 和 @Validated 的选择

- **@Valid**：适用于简单的验证场景，无需分组。它是标准JSR-303规范的一部分，与Spring的集成自然不如`@Validated`灵活。
- **@Validated**：Spring特有的验证注解，支持分组功能，更适合复杂的验证场景，如同一个对象在不同的操作中需要不同的验证规则。

因此，当你的验证需求包括分组功能时，你应该选择使用 `@Validated`。这使得在Spring框架中，你可以更灵活地控制验证逻辑，确保根据具体的业务规则对数据进行正确的校验。



# 8 校验注解@Valid抛出异常和不抛出异常的两种情况

总结如下：

**在Spring MVC中，使用`@Valid`或`@Validated`对方法参数进行校验时，有两种处理校验失败的方式：如果参数列表中包含`BindingResult`，所有校验错误将被收集在此对象中，方法继续执行，允许开发者在方法内部手动处理这些错误；如果不包含`BindingResult`，任何校验错误将导致Spring自动抛出`MethodArgumentNotValidException`，这是`BindException`的子类，通常需要在全局异常处理器中被捕捉并处理。这样的设计允许在控制器层灵活地决定如何响应校验错误，无论是直接处理或通过异常机制统一管理。**





当在Spring框架中使用`@Valid`或`@Validated`注解进行数据校验失败时，通常不会直接抛出一个运行时异常。相反，校验失败会被Spring的校验机制捕捉，并且通过特定的异常处理流程来管理。让我们详细解析这一过程。

### 校验过程与异常处理

1. **校验执行**：
   - 当一个请求到达Spring MVC控制器的方法，且该方法的参数前有`@Valid`或`@Validated`注解时，Spring会自动执行绑定和校验过程。
   - 如果参数校验失败（即`isValid`方法返回`false`），Spring构建一个包含校验失败信息的`BindingResult`或`Errors`对象。

2. **异常触发**：
   - 在Spring MVC中，如果方法参数后紧跟一个`BindingResult`，则所有的校验错误都会被收集在这个`BindingResult`对象中，方法将正常执行，开发者需要手动检查`BindingResult`有无错误并处理。
   - 如果没有`BindingResult`参数跟随，Spring MVC将会抛出`MethodArgumentNotValidException`异常，该异常是`BindException`的子类，用来表示方法参数校验失败。

3. **异常处理**：
   - 你已经在`GlobalExceptionHandler`类中定义了对`BindException`的处理逻辑。当`MethodArgumentNotValidException`（即一种`BindException`）被抛出时，它会被这个异常处理器捕捉。
   - 异常处理器将校验失败的信息转换为你定义的错误格式，并返回给前端。这允许前端接收到具体的错误信息，并据此显示相应的用户提示。

### 全局异常处理器中的代码

你的全局异常处理器代码如下：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public RespBean ExceptionHandler(Exception e) {
        if (e instanceof GlobalException) {
            GlobalException ex = (GlobalException) e;
            return RespBean.error(ex.getRespBeanEnum());
        } else if (e instanceof BindException) {
            BindException ex = (BindException) e;
            RespBean respBean = RespBean.error(RespBeanEnum.BIND_ERROR);
            respBean.setMessage("参数校验异常~：" + ex.getBindingResult().getAllErrors().get(0).getDefaultMessage());
            return respBean;
        }
        return RespBean.error(RespBeanEnum.ERROR);
    }
}
```

### 为什么使用绑定异常处理非法输入

- 当`@Validated`或`@Valid`注解在控制器参数中用于校验并且校验失败时，由于你没有在方法参数中提供`BindingResult`来手动处理错误，Spring会自动抛出`MethodArgumentNotValidException`。
- 由于`MethodArgumentNotValidException`是`BindException`的一个特定形式，它被你的`GlobalExceptionHandler`中对`BindException`的处理逻辑捕获并处理。

### 总结

因此，当前端输入的手机号不合法，并且这一信息没有被一个随后的`BindingResult`参数捕获，Spring会抛出`MethodArgumentNotValidException`。这个异常在你的全局异常处理器中被识别为`BindException`，并相应地生成错误响应返回给前端。这是一个优雅的错误处理机制，确保用户得到清晰的反馈而不会影响服务器的稳定性。



## 2 如果有在随后的BindingResult参数捕获，就不会抛出这个MethodArgumentNotValidException异常了？

正是如此，如果你在Spring MVC控制器方法的参数列表中，在使用了`@Valid`或`@Validated`注解的参数后面紧跟一个`BindingResult`参数，Spring将不会抛出`MethodArgumentNotValidException`异常。相反，所有的校验错误将被收集在`BindingResult`对象中。这样，你就可以在方法内部检查是否存在错误，并根据错误存在与否进行适当的处理。

### 示例说明

假设你有以下的控制器方法：

```java
@RequestMapping("/register")
public ResponseEntity<?> registerUser(@Valid @RequestBody UserRegistrationDto userDto, BindingResult result) {
    if (result.hasErrors()) {
        // 提取错误信息，并构造响应体
        List<String> errorMessages = result.getAllErrors()
                                           .stream()
                                           .map(ObjectError::getDefaultMessage)
                                           .collect(Collectors.toList());
        return ResponseEntity.badRequest().body(errorMessages);
    }
    // 如果没有错误，继续执行业务逻辑
    userService.register(user);
    return ResponseEntity.ok("User registered successfully");
}
```

在这个例子中：

- `@Valid @RequestBody UserRegistrationDto userDto`：这是一个要验证的DTO对象。
- `BindingResult result`：这个参数紧跟在被验证的对象后面，用于收集和访问校验过程中产生的错误。

### 校验错误处理流程

1. **校验执行**：当请求到达时，Spring会对`UserRegistrationDto`对象进行校验。
2. **错误收集**：如果存在校验错误，这些错误会被自动收集到`BindingResult`对象中。
3. **错误检查与响应**：在方法内部，你可以使用`result.hasErrors()`来检查是否有错误发生。如果有错误，可以从`BindingResult`中提取具体的错误信息，并据此构造一个适当的响应返回给前端。

### 如果没有BindingResult参数

- 如果没有`BindingResult`参数跟随，且存在校验错误，Spring会自动抛出`MethodArgumentNotValidException`。这种情况下，你需要在全局异常处理器中捕获和处理这个异常。

### 优点与缺点

**优点**：

- 提供了一种灵活的方式来处理校验错误，可以根据具体情况决定如何响应。
- 允许在相同的请求处理流程中同时处理正常逻辑和错误逻辑，保持代码的连贯性。

**缺点**：

- 如果每个方法都要编写错误处理代码，可能会导致代码重复，特别是当多个方法需要相似的错误处理逻辑时。

### 总结

通过在方法参数中使用`BindingResult`，你可以避免`MethodArgumentNotValidException`的抛出，并且可以在控制器内部更灵活地处理校验错误。这种方式特别适合需要在同一方法中处理多种结果的场景，允许开发者根据实际需要定制错误响应。



# 9 当你集成了`spring-session-data-redis`，Spring Session框架会接管应用的HTTP Session,其中Spring Session不使用传统的`JSESSIONID`，而是使用`SESSION`作为Cookie名称。

将Session保存到Redis和使用`spring-session-data-redis`依赖是关键点。这种变化（`JSESSIONID`变成`SESSION`，以及Session值位数变多）是因为Spring Session的工作机制引起的。下面是详细的解释：

### 1. SESSION 替代 JSESSIONID

当你集成了`spring-session-data-redis`，Spring Session框架会接管应用的HTTP Session管理。默认情况下，Spring Session不使用传统的`JSESSIONID`作为Cookie名称，而是使用`SESSION`。这是为了避免和Servlet容器（如Tomcat）默认的Session管理冲突，特别是在分布式Session环境中。

### 2. Session ID 格式变化

你提到的Session ID格式变化（例如："ODZiOTZmNzMtY2U3Mi00Y2MwLWE2NTMtZjExNmRiOTA1MzAx"），这种格式是一个基于UUID的字符串。Spring Session默认使用这种更安全的UUID格式来生成Session ID，以增强安全性。UUID格式的Session ID更难被预测，这有助于防止Session劫持等安全问题。

### 3. 配置和使用

如果你想要回到使用`JSESSIONID`，或者自定义Session ID的生成策略，你可以在Spring的配置中进行调整。例如，要修改Cookie名称为`JSESSIONID`，可以通过以下配置：

```java
import org.springframework.session.web.http.DefaultCookieSerializer;

@Configuration
@EnableRedisHttpSession
public class SessionConfig {

    @Bean
    public DefaultCookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("JSESSIONID");  // 设置为传统的JSESSIONID
        return serializer;
    }
}
```

这段配置定义了一个Bean，用于自定义Cookie序列化器，将Session Cookie的名称改回传统的`JSESSIONID`。

### 4. 结论

引入`spring-session-data-redis`是为了提高Session的可扩展性和可靠性，尤其是在分布式系统中。这种改变（使用`SESSION`和UUID格式的Session ID）虽然带来了一些初步的困扰，但从长远来看，为系统的扩展和安全提供了保障。如果需要，可以通过配置调整这些默认行为以适应特定的需求。



# 10 为什么UserArgumentResolver解析器的supportsParameter方法中 `aClass == User.class;` 选择使用 == 而非其他类型检查方法



~~~java


/**
 * @author yangda
 * @create 2024-04-23-19:20
 * @description: springboot的解析器机制
 * UserArgumentResolver 是我们自定义的一个 用户参数解析器
 * 用来解析浏览器到Controller层的方法之前，对参数
 * 根据 Cookie、request、response、业务service方法 进行解析/封装 User对象
 * 在Controller层的方法形参位置，可以直接拿到User对象的具体信息
 *
 * 注意:
 * 1. 所有的请求在到达控制层方法之前，都会经过该解析器处理，进行判断，控制层方法的形参中是否有
 *    这里需要解析的User.class 类型的参数，如果有则进行解析封装
 * 2. 需要将我们这里自定义的 UserArgumentResolver 解析器
 *    加入到WebMvcConfigurer接口的实现类WebConfig中的
 *    HandlerMethodArgumentResolver 列表中之后，该UserArgumentResolver解析器才生效！！！
 *
 */
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {

    // @Autowired
    @Resource
    private UserService userService;


    //该方法 判断你当前要解析的参数类型是不是你需要的
    //如果这个方法返回 true 才会执行下面的 resolveArgument 方法
    //返回 false 不执行下面的方法
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        //获取参数的类型
        Class<?> aClass = parameter.getParameterType();
        //判断aClass是不是 user 类型，如果为 true,
        // 就执行 resolveArgument，Dog Cat Person等类型都可以，根据实际情况进行封装
        return aClass == User.class;

        // 为什么 `aClass == User.class;` 选择使用 == 而非其他类型检查方法
        // 使用 == 检查参数类型是否严格为 User 类型
        // 使用 == 是适当的，因为：
        // 1. 类型标识：`==` 检查两个类对象是否指向同一个 Class 实例。
        // 2. 类对象唯一性：对于任何给定的由特定类加载器加载的类，JVM 都保证只有一个 Class 对象。
        // 3. 性能优势：使用 `==` 比较内存地址比使用 `instanceof`（还考虑子类）性能更好。
        // 4. 使用场景：此处需要确保参数类型不仅是 User 类型，而且不包括其子类。
    }

    /**
     * 如果上面的supportsParameter返回true,就执行下面的resolveArgument方法
     * 到底怎么解析，是由程序员根据业务来编写
     * 这个方法，类似拦截器，将传入的参数，取出 cookie 值，然后获取对应的 User 对象
     * 并把这个 User 对象作为参数继续传递.
     * @param parameter
     * @param mavContainer
     * @param webRequest
     * @param binderFactory
     * @return
     * @throws Exception
     */
    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer
            mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)
            throws Exception {
        HttpServletRequest request =
                webRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response =
                webRequest.getNativeResponse(HttpServletResponse.class);

        String ticket = CookieUtil.getCookieValue(request, "userTicket");
        if (!StringUtils.hasText(ticket)) {
            return null;
        }
        //根据 cookie-ticket 到 Redis 获取 User用户信息
        User user = userService.getUserByCookie(ticket, request, response);

        //这里返回，相当于直接返回到/封装到了Controller层的控制器方法形参位置上了，
        //即如果Controller层的方法 如果使用到参数类型为User.class类型的参数，会直接
        //被封装为从Redis中根据cookie等获取到的具体的user对象的信息
        return user;
    }
}

~~~





在你的 `UserArgumentResolver` Java 类中使用 `==` 来比较参数的类与 `User` 类是正确的，这样的用法能够如你所预期地工作。

以下是为什么可以这样用的原因：

1. **类型标识：** 在 Java 中，使用 `==` 运算符比较类对象时，它检查类型标识。这意味着它验证两个操作数是否引用内存中相同的 `Class` 对象。在 Java 环境中，由类加载器加载的每个类都由唯一的 `Class` 对象表示。因此，`aClass == User.class` 检查参数的类是否确切地是 `User`，而不是子类或其他任何类。

2. **类对象的唯一性：** JVM 确保对于特定类加载器加载的任何给定类，将只有一个 `Class` 对象。这保证了使用 `==` 进行比较能有效地确定一个类是否为特定类型。

3. **性能：** 使用 `==` 进行类比较是高效的，因为它仅比较内存地址，而不进行更复杂的检查，如 `instanceof`，后者还考虑了子类。

4. **使用场景的具体性：** 在你的方法中，你明确检查参数是否确切地为 `User` 类型（不包括子类），在这种情况下使用 `==` 是适当的。如果你想检查参数是否为 `User` 的实例或其子类，你应该使用 `instanceof` 运算符。

总之，在你的 `supportsParameter` 方法中使用 `==` 来检查 `parameter.getParameterType()` 是否确切地为 `User.class` 既正确又适当，考虑到在 Java 类比较场景中的具体性和性能考虑。



# 11 在使用 MyBatis-Plus 的情况下，许多基本的 CRUD 操作和属性到数据库列的映射已经由框架自动处理，特别是当你使用了 `@TableName` 和 `@TableId` 注解来明确指定了表名和主键列时。MyBatis-Plus 默认支持驼峰命名到下划线命名的自动转换，这可以覆盖大多数日常需求。因此，你可能会觉得在这种情况下使用自定义 `resultMap` 有些多余。

然而，编写自定义的 `resultMap` 还是有其用处和优点的，尤其是在一些特定场景下：

1. **复杂关联和集成**: 当你的查询需要涉及到多表联查、复杂的列到属性的映射、或者当数据库列和实体类属性不能直接对应时（例如，继承关系中的属性，或者需要特定的类型处理器），`resultMap` 可以提供更大的灵活性和控制力。

2. **非标准的映射需求**: 如果某些字段的映射不遵循常规的驼峰到下划线规则，或者需要进行特殊处理（比如使用 SQL 函数处理数据后再映射到实体属性上），`resultMap` 就显得尤为重要。

3. **优化和性能考虑**: 在一些高性能需求的场景中，可能需要对查询的结果集进行细粒度控制，包括但不限于指定加载的列、处理懒加载等。通过 `resultMap`，你可以精确地控制哪些列被加载，以及它们是如何被处理和转换的。

4. **明确的映射声明**: `resultMap` 提供了一种清晰明确的方式来描述数据库列和 Java 实体类属性之间的映射关系。这种显式的映射声明在维护大型项目或多人协作的项目时尤为有价值，因为它使得映射关系更加透明和易于理解。

在你的例子中，如果 `Order` 类和数据库表 `t_order` 的映射是标准且直接的（即遵循 MyBatis-Plus 的默认映射策略），并且没有涉及到上述复杂的情况，那么自定义 `resultMap` 可能看起来有些多余。但是，如果项目需求中包含了上述情况中的一种或多种，那么编写和使用自定义 `resultMap` 就非常有意义了。



## 示例：

当然，让我们探讨一下在使用自定义 `resultMap` 在 MyBatis 或 MyBatis-Plus 中可能遇到的几种实用场景：

### 1. 复杂关联和集成

**场景**: 假设你有一个电商应用，其中 `Order` 实体需要关联 `User` 和 `Product` 实体，以获取用户信息和产品详情。这种情况下，你的查询可能需要从多个表中拉取数据。

```xml
<resultMap id="OrderDetailResultMap" type="com.hspedu.seckill.pojo.Order">
    <id column="id" property="id" />
    <result column="user_name" property="user.name" />
    <result column="product_name" property="product.name" />
    <result column="product_price" property="product.price" />
    <association property="user" javaType="com.hspedu.seckill.pojo.User">
        <result column="user_id" property="id" />
        <result column="user_name" property="name" />
    </association>
    <association property="product" javaType="com.hspedu.seckill.pojo.Product">
        <result column="product_id" property="id" />
        <result column="product_name" property="name" />
        <result column="product_price" property="price" />
    </association>
</resultMap>
```

### 2. 非标准的映射需求

**场景**: 考虑一个用户的积分系统，其中数据库存储的是用户的生日，但你需要计算用户的年龄来显示。这需要在 SQL 查询中使用数据库函数来计算年龄，并将结果映射到实体类中的年龄属性。

```xml
<resultMap id="UserWithAgeResultMap" type="com.hspedu.seckill.pojo.User">
    <id column="id" property="id" />
    <result column="name" property="name" />
    <result column="birthday" property="birthday" />
    <!-- 使用数据库函数计算年龄 -->
    <result column="DATEDIFF(CURDATE(), birthday) / 365" property="age" />
</resultMap>
```

### 3. 优化和性能考虑

**场景**: 如果你正在处理一个报表系统，需要从大量数据中提取汇总信息。在这种情况下，你可能不需要加载所有列，只需特定的几列来优化性能。

```xml
<resultMap id="OrderSummaryResultMap" type="com.hspedu.seckill.pojo.Order">
    <id column="id" property="id" />
    <result column="order_date" property="orderDate" />
    <!-- 只加载订单总金额和状态，不加载其他详情以提高查询效率 -->
    <result column="total_amount" property="totalAmount" />
    <result column="status" property="status" />
</resultMap>
```

### 4. 明确的映射声明

**场景**: 当数据库表结构复杂或包含大量字段时，明确地通过 `resultMap` 声明映射关系可以帮助新成员更快理解数据结构和代码，尤其是在需要符合特定业务逻辑处理的大型企业应用中。

```xml
<resultMap id="ComplexUserResultMap" type="com.hspedu.seckill.pojo.User">
    <id column="id" property="id" />
    <result column="first_name" property="firstName" />
    <result column="last_name" property="lastName" />
    <result column="email" property="email" />
    <!-- 明确映射可以减少误解，特别是当列名和属性名不直观对应时 -->
</resultMap>
```

这些例子展示了在不同情况下，自定义 `resultMap` 如何提供额外的灵活性和控制，有助于处理特定需求，优化性能，并提高代码的可维护性和可理解性。



# 12 mybatis默认不支持驼峰法映射，但是mybatis-plus默认是支持驼峰法映射的

MyBatis 和 MyBatis-Plus 在处理属性和数据库列映射的默认行为上有所不同，这确实影响了是否需要额外配置 `resultMap`。

### MyBatis 的默认行为
- **非自动映射**：MyBatis 默认并不自动进行驼峰命名（camelCase）到下划线（underscore）的转换。如果数据库的列名是下划线风格，而Java实体属性是驼峰风格，开发者通常需要手动配置映射关系，或者在 MyBatis 的配置文件中设置 `mapUnderscoreToCamelCase` 为 `true` 来启用自动映射。
  
```xml
<settings>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

这个设置告诉 MyBatis 在执行 SQL 映射到 Java 实体时，自动把数据库中的下划线命名转换成Java实体的驼峰命名。

### MyBatis-Plus 的默认行为
- **自动映射**：MyBatis-Plus 默认支持驼峰到下划线的自动转换。这意味着在大多数常见场景下，你不需要手动写 `resultMap` 来处理基本的属性映射。此外，MyBatis-Plus 提供了许多方便的功能，如自动的 CRUD 操作和更简单的查询构造，这些都是基于约定优于配置的原则。

因此，如果你在使用 MyBatis-Plus，并且你的数据模型与数据库列直接对应（遵循驼峰和下划线自动映射规则），你可能不需要频繁使用 `resultMap`。但如之前所述，对于复杂的SQL操作，如多表联合、非标准列映射、复杂的聚合或特定的优化需求，自定义 `resultMap` 仍然是有用的。

总结一下，选择使用 MyBatis 还是 MyBatis-Plus 取决于项目的需求以及你对框架提供的便利性和灵活性的需求。如果项目中有大量标准化的数据库操作，并且希望尽可能减少配置的工作量，MyBatis-Plus 是一个很好的选择。但对于需要精细控制SQL表达和数据映射处理的复杂业务场景，MyBatis 提供了更多的控制力和灵活性。

